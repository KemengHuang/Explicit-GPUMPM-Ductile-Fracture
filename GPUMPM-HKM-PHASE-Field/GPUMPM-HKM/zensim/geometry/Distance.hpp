#pragma once
#include "zensim/math/MathUtils.h"
#include "zensim/math/Vec.h"
#include "zensim/math/VecInterface.hpp"

namespace zs {

  /// ref: ipc-sim/Codim-IPC, Math/Distance/EDGE_EDGE.h
  //
  //! point-point
  //
  template <
      typename VecTA, typename VecTB,
      enable_if_all<VecTA::dim == 1, is_same_v<typename VecTA::dims, typename VecTB::dims>> = 0>
  constexpr auto dist2_pp(const VecInterface<VecTA> &a, const VecInterface<VecTB> &b) noexcept {
    return (b - a).l2NormSqr();
  }
  template <
      typename VecTA, typename VecTB,
      enable_if_all<VecTA::dim == 1, is_same_v<typename VecTA::dims, typename VecTB::dims>> = 0>
  constexpr auto dist_pp(const VecInterface<VecTA> &a, const VecInterface<VecTB> &b) noexcept {
    return zs::sqrt(dist2_pp(a, b));
  }

  template <
      typename VecTA, typename VecTB,
      enable_if_all<VecTA::dim == 1, is_same_v<typename VecTA::dims, typename VecTB::dims>> = 0>
  constexpr auto dist_grad_pp(const VecInterface<VecTA> &a, const VecInterface<VecTB> &b) noexcept {
    using T = math::op_result_t<typename VecTA::value_type, typename VecTB::value_type>;
    using Ti = typename VecTA::index_type;
    constexpr int dim = VecTA::extent;
    using GradT = typename VecTA::template variant_vec<T, integer_seq<Ti, 2, dim>>;
    GradT grad{};
    for (int d = 0; d != dim; ++d) {
      auto v = 2 * (a(d) - b(d));
      grad(0, d) = v;
      grad(1, d) = -v;
    }
    return grad;
  }
  template <
      typename VecTA, typename VecTB,
      enable_if_all<VecTA::dim == 1, is_same_v<typename VecTA::dims, typename VecTB::dims>> = 0>
  constexpr auto dist_hess_pp(const VecInterface<VecTA> &a, const VecInterface<VecTB> &b) noexcept {
    using T = math::op_result_t<typename VecTA::value_type, typename VecTB::value_type>;
    using Ti = typename VecTA::index_type;
    constexpr int dim = VecTA::extent;
    using HessT = typename VecTA::template variant_vec<T, integer_seq<Ti, dim * 2, dim * 2>>;
    auto hess = HessT::identity() * 2;
    if constexpr (dim == 2)
      hess(0, 2) = hess(1, 3) = hess(2, 0) = hess(3, 1) = -2;
    else if constexpr (dim == 3)
      hess(0, 3) = hess(1, 4) = hess(2, 5) = hess(3, 0) = hess(4, 1) = hess(5, 2) = -2;
    return hess;
  }

  //
  //! point-edge
  //
  namespace detail {
    template <class T, typename VecT>
    constexpr void g_PE2D(T v01, T v02, T v11, T v12, T v21, T v22, VecInterface<VecT> &g) {
      T t13{};
      T t14{};
      T t23{};
      T t25{};
      T t24{};
      T t26{};
      T t27{};

      /* G_PE2D */
      /*     G = G_PE2D(V01,V02,V11,V12,V21,V22) */
      /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
      /*     16-Mar-2020 15:56:29 */
      t13 = -v21 + v11;
      t14 = -v22 + v12;
      t23 = 1.0 / (t13 * t13 + t14 * t14);
      t25 = ((v11 * v22 + -(v12 * v21)) + t14 * v01) + -(t13 * v02);
      t24 = t23 * t23;
      t26 = t25 * t25;
      t27 = (v11 * 2.0 + -(v21 * 2.0)) * t24 * t26;
      t26 *= (v12 * 2.0 + -(v22 * 2.0)) * t24;
      g.val(0) = t14 * t23 * t25 * 2.0;
      g.val(1) = t13 * t23 * t25 * -2.0;
      t24 = t23 * t25;
      g.val(2) = -t27 - t24 * (-v22 + v02) * 2.0;
      g.val(3) = -t26 + t24 * (-v21 + v01) * 2.0;
      g.val(4) = t27 + t24 * (v02 - v12) * 2.0;
      g.val(5) = t26 - t24 * (v01 - v11) * 2.0;
    }

    template <class T, typename VecT> constexpr void g_PE3D(T v01, T v02, T v03, T v11, T v12,
                                                            T v13, T v21, T v22, T v23,
                                                            VecInterface<VecT> &g) {
      T t17{};
      T t18{};
      T t19{};
      T t20{};
      T t21{};
      T t22{};
      T t23{};
      T t24{};
      T t25{};
      T t42{};
      T t44{};
      T t45{};
      T t46{};
      T t43{};
      T t50{};
      T t51{};
      T t52{};

      /* G_PE */
      /*     G = G_PE(V01,V02,V03,V11,V12,V13,V21,V22,V23) */
      /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
      /*     10-Jun-2019 18:02:37 */
      t17 = -v11 + v01;
      t18 = -v12 + v02;
      t19 = -v13 + v03;
      t20 = -v21 + v01;
      t21 = -v22 + v02;
      t22 = -v23 + v03;
      t23 = -v21 + v11;
      t24 = -v22 + v12;
      t25 = -v23 + v13;
      t42 = 1.0 / ((t23 * t23 + t24 * t24) + t25 * t25);
      t44 = t17 * t21 + -(t18 * t20);
      t45 = t17 * t22 + -(t19 * t20);
      t46 = t18 * t22 + -(t19 * t21);
      t43 = t42 * t42;
      t50 = (t44 * t44 + t45 * t45) + t46 * t46;
      t51 = (v11 * 2.0 + -(v21 * 2.0)) * t43 * t50;
      t52 = (v12 * 2.0 + -(v22 * 2.0)) * t43 * t50;
      t43 = (v13 * 2.0 + -(v23 * 2.0)) * t43 * t50;
      g.val(0) = t42 * (t24 * t44 * 2.0 + t25 * t45 * 2.0);
      g.val(1) = -t42 * (t23 * t44 * 2.0 - t25 * t46 * 2.0);
      g.val(2) = -t42 * (t23 * t45 * 2.0 + t24 * t46 * 2.0);
      g.val(3) = -t51 - t42 * (t21 * t44 * 2.0 + t22 * t45 * 2.0);
      g.val(4) = -t52 + t42 * (t20 * t44 * 2.0 - t22 * t46 * 2.0);
      g.val(5) = -t43 + t42 * (t20 * t45 * 2.0 + t21 * t46 * 2.0);
      g.val(6) = t51 + t42 * (t18 * t44 * 2.0 + t19 * t45 * 2.0);
      g.val(7) = t52 - t42 * (t17 * t44 * 2.0 - t19 * t46 * 2.0);
      g.val(8) = t43 - t42 * (t17 * t45 * 2.0 + t18 * t46 * 2.0);
    }

    template <typename T, typename VecT>
    constexpr void H_PE2D(T v01, T v02, T v11, T v12, T v21, T v22, VecInterface<VecT> &H) {
      T t15{};
      T t16{};
      T t17{};
      T t18{};
      T t19{};
      T t20{};
      T t21{};
      T t22{};
      T t23{};
      T t24{};
      T t31{};
      T t34{};
      T t32{};
      T t33{};
      T t35{};
      T t60{};
      T t59{};
      T t62{};
      T t64{};
      T t65{};
      T t68{};
      T t71{};
      T t72{};
      T t75{};
      T t76{};
      T t77{};
      T t78{};
      T t79{};
      T t90{};
      T t92{};
      T t94{};
      T t96{};
      T t99{};
      T t93{};
      T t97{};
      T t98{};
      T t100{};
      T t102_tmp{};

      /* H_PE2D */
      /*     H = H_PE2D(V01,V02,V11,V12,V21,V22) */
      /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
      /*     16-Mar-2020 15:56:29 */
      t15 = -v11 + v01;
      t16 = -v12 + v02;
      t17 = -v21 + v01;
      t18 = -v22 + v02;
      t19 = -v21 + v11;
      t20 = -v22 + v12;
      t21 = v11 * 2.0 + -(v21 * 2.0);
      t22 = v12 * 2.0 + -(v22 * 2.0);
      t23 = t19 * t19;
      t24 = t20 * t20;
      t31 = 1.0 / (t23 + t24);
      t34 = ((v11 * v22 + -(v12 * v21)) + t20 * v01) + -(t19 * v02);
      t32 = t31 * t31;
      // t33 = zs::pow(t31, 3.0);
      t33 = t31 * t31 * t31;
      t35 = t34 * t34;
      t60 = t31 * t34 * 2.0;
      t59 = -(t19 * t20 * t31 * 2.0);
      t62 = t32 * t35 * 2.0;
      t64 = t21 * t21 * t33 * t35 * 2.0;
      t65 = t22 * t22 * t33 * t35 * 2.0;
      t68 = t15 * t21 * t32 * t34 * 2.0;
      t71 = t16 * t22 * t32 * t34 * 2.0;
      t72 = t17 * t21 * t32 * t34 * 2.0;
      t75 = t18 * t22 * t32 * t34 * 2.0;
      t76 = t19 * t21 * t32 * t34 * 2.0;
      t77 = t20 * t21 * t32 * t34 * 2.0;
      t78 = t19 * t22 * t32 * t34 * 2.0;
      t79 = t20 * t22 * t32 * t34 * 2.0;
      t90 = t21 * t22 * t33 * t35 * 2.0;
      t92 = t16 * t20 * t31 * 2.0 + t77;
      t94 = -(t17 * t19 * t31 * 2.0) + t78;
      t96 = (t18 * t19 * t31 * 2.0 + -t60) + t76;
      t99 = (-(t15 * t20 * t31 * 2.0) + -t60) + t79;
      t93 = t15 * t19 * t31 * 2.0 + -t78;
      t35 = -(t18 * t20 * t31 * 2.0) + -t77;
      t97 = (t17 * t20 * t31 * 2.0 + t60) + -t79;
      t98 = (-(t16 * t19 * t31 * 2.0) + t60) + -t76;
      t100 = ((-(t15 * t16 * t31 * 2.0) + t71) + -t68) + t90;
      t19 = ((-(t17 * t18 * t31 * 2.0) + t75) + -t72) + t90;
      t102_tmp = t17 * t22 * t32 * t34;
      t76 = t15 * t22 * t32 * t34;
      t22 = (((-(t15 * t17 * t31 * 2.0) + t62) + -t65) + t76 * 2.0) + t102_tmp * 2.0;
      t33 = t18 * t21 * t32 * t34;
      t20 = t16 * t21 * t32 * t34;
      t79 = (((-(t16 * t18 * t31 * 2.0) + t62) + -t64) + -(t20 * 2.0)) + -(t33 * 2.0);
      t77 = (((t15 * t18 * t31 * 2.0 + t60) + t68) + -t75) + -t90;
      t78 = (((t16 * t17 * t31 * 2.0 + -t60) + t72) + -t71) + -t90;
      H.val(0) = t24 * t31 * 2.0;
      H.val(1) = t59;
      H.val(2) = t35;
      H.val(3) = t97;
      H.val(4) = t92;
      H.val(5) = t99;
      H.val(6) = t59;
      H.val(7) = t23 * t31 * 2.0;
      H.val(8) = t96;
      H.val(9) = t94;
      H.val(10) = t98;
      H.val(11) = t93;
      H.val(12) = t35;
      H.val(13) = t96;
      t35 = -t62 + t64;
      H.val(14) = (t35 + t18 * t18 * t31 * 2.0) + t33 * 4.0;
      H.val(15) = t19;
      H.val(16) = t79;
      H.val(17) = t77;
      H.val(18) = t97;
      H.val(19) = t94;
      H.val(20) = t19;
      t33 = -t62 + t65;
      H.val(21) = (t33 + t17 * t17 * t31 * 2.0) - t102_tmp * 4.0;
      H.val(22) = t78;
      H.val(23) = t22;
      H.val(24) = t92;
      H.val(25) = t98;
      H.val(26) = t79;
      H.val(27) = t78;
      H.val(28) = (t35 + t16 * t16 * t31 * 2.0) + t20 * 4.0;
      H.val(29) = t100;
      H.val(30) = t99;
      H.val(31) = t93;
      H.val(32) = t77;
      H.val(33) = t22;
      H.val(34) = t100;
      H.val(35) = (t33 + t15 * t15 * t31 * 2.0) - t76 * 4.0;
    }

    template <typename T, typename VecT> constexpr void H_PE3D(T v01, T v02, T v03, T v11, T v12,
                                                               T v13, T v21, T v22, T v23,
                                                               VecInterface<VecT> &H) {
      T t17{};
      T t18{};
      T t19{};
      T t20{};
      T t21{};
      T t22{};
      T t23{};
      T t24{};
      T t25{};
      T t26{};
      T t27{};
      T t28{};
      T t35{};
      T t36{};
      T t37{};
      T t50{};
      T t51{};
      T t52{};
      T t53{};
      T t54{};
      T t55{};
      T t56{};
      T t62{};
      T t70{};
      T t71{};
      T t75{};
      T t79{};
      T t80{};
      T t84{};
      T t88{};
      T t38{};
      T t39{};
      T t40{};
      T t41{};
      T t42{};
      T t43{};
      T t44{};
      T t46{};
      T t48{};
      T t57{};
      T t58{};
      T t60{};
      T t63{};
      T t65{};
      T t67{};
      T t102{};
      T t103{};
      T t104{};
      T t162{};
      T t163{};
      T t164{};
      T t213{};
      T t214{};
      T t215{};
      T t216{};
      T t217{};
      T t218{};
      T t225{};
      T t226{};
      T t227{};
      T t229{};
      T t230{};
      T t311{};
      T t231{};
      T t232{};
      T t233{};
      T t234{};
      T t235{};
      T t236{};
      T t237{};
      T t238{};
      T t239{};
      T t240{};
      T t245{};
      T t279{};
      T t281{};
      T t282{};
      T t283{};
      T t287{};
      T t289{};
      T t247{};
      T t248{};
      T t249{};
      T t250{};
      T t251{};
      T t252{};
      T t253{};
      T t293{};
      T t295{};
      T t299{};
      T t300{};
      T t303{};
      T t304{};
      T t294{};
      T t297{};
      T t301{};
      T t302{};

      /* H_PE */
      /*     H = H_PE(V01,V02,V03,V11,V12,V13,V21,V22,V23) */
      /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
      /*     10-Jun-2019 18:02:39 */
      t17 = -v11 + v01;
      t18 = -v12 + v02;
      t19 = -v13 + v03;
      t20 = -v21 + v01;
      t21 = -v22 + v02;
      t22 = -v23 + v03;
      t23 = -v21 + v11;
      t24 = -v22 + v12;
      t25 = -v23 + v13;
      t26 = v11 * 2.0 + -(v21 * 2.0);
      t27 = v12 * 2.0 + -(v22 * 2.0);
      t28 = v13 * 2.0 + -(v23 * 2.0);
      t35 = t23 * t23;
      t36 = t24 * t24;
      t37 = t25 * t25;
      t50 = t17 * t21;
      t51 = t18 * t20;
      t52 = t17 * t22;
      t53 = t19 * t20;
      t54 = t18 * t22;
      t55 = t19 * t21;
      t56 = t17 * t20 * 2.0;
      t62 = t18 * t21 * 2.0;
      t70 = t19 * t22 * 2.0;
      t71 = t17 * t23 * 2.0;
      t75 = t18 * t24 * 2.0;
      t79 = t19 * t25 * 2.0;
      t80 = t20 * t23 * 2.0;
      t84 = t21 * t24 * 2.0;
      t88 = t22 * t25 * 2.0;
      t38 = t17 * t17 * 2.0;
      t39 = t18 * t18 * 2.0;
      t40 = t19 * t19 * 2.0;
      t41 = t20 * t20 * 2.0;
      t42 = t21 * t21 * 2.0;
      t43 = t22 * t22 * 2.0;
      t44 = t35 * 2.0;
      t46 = t36 * 2.0;
      t48 = t37 * 2.0;
      t57 = t50 * 2.0;
      t58 = t51 * 2.0;
      t60 = t52 * 2.0;
      t63 = t53 * 2.0;
      t65 = t54 * 2.0;
      t67 = t55 * 2.0;
      t102 = 1.0 / ((t35 + t36) + t37);
      t36 = t50 + -t51;
      t35 = t52 + -t53;
      t37 = t54 + -t55;
      t103 = t102 * t102;
      // t104 = zs::pow(t102, 3.0);
      t104 = t102 * t102 * t102;
      t162 = -(t23 * t24 * t102 * 2.0);
      t163 = -(t23 * t25 * t102 * 2.0);
      t164 = -(t24 * t25 * t102 * 2.0);
      t213 = t18 * t36 * 2.0 + t19 * t35 * 2.0;
      t214 = t17 * t35 * 2.0 + t18 * t37 * 2.0;
      t215 = t21 * t36 * 2.0 + t22 * t35 * 2.0;
      t216 = t20 * t35 * 2.0 + t21 * t37 * 2.0;
      t217 = t24 * t36 * 2.0 + t25 * t35 * 2.0;
      t218 = t23 * t35 * 2.0 + t24 * t37 * 2.0;
      t35 = (t36 * t36 + t35 * t35) + t37 * t37;
      t225 = t17 * t36 * 2.0 + -(t19 * t37 * 2.0);
      t226 = t20 * t36 * 2.0 + -(t22 * t37 * 2.0);
      t227 = t23 * t36 * 2.0 + -(t25 * t37 * 2.0);
      t36 = t26 * t103;
      t229 = t36 * t213;
      t37 = t27 * t103;
      t230 = t37 * t213;
      t311 = t28 * t103;
      t231 = t311 * t213;
      t232 = t36 * t214;
      t233 = t37 * t214;
      t234 = t311 * t214;
      t235 = t36 * t215;
      t236 = t37 * t215;
      t237 = t311 * t215;
      t238 = t36 * t216;
      t239 = t37 * t216;
      t240 = t311 * t216;
      t214 = t36 * t217;
      t215 = t37 * t217;
      t216 = t311 * t217;
      t217 = t36 * t218;
      t245 = t37 * t218;
      t213 = t311 * t218;
      t279 = t103 * t35 * 2.0;
      t281 = t26 * t26 * t104 * t35 * 2.0;
      t282 = t27 * t27 * t104 * t35 * 2.0;
      t283 = t28 * t28 * t104 * t35 * 2.0;
      t287 = t26 * t27 * t104 * t35 * 2.0;
      t218 = t26 * t28 * t104 * t35 * 2.0;
      t289 = t27 * t28 * t104 * t35 * 2.0;
      t247 = t36 * t225;
      t248 = t37 * t225;
      t249 = t311 * t225;
      t250 = t36 * t226;
      t251 = t37 * t226;
      t252 = t311 * t226;
      t253 = t36 * t227;
      t35 = t37 * t227;
      t36 = t311 * t227;
      t293 = t102 * (t75 + t79) + t214;
      t295 = -(t102 * (t80 + t84)) + t213;
      t299 = t102 * ((t63 + t22 * t23 * 2.0) + -t60) + t217;
      t300 = t102 * ((t67 + t22 * t24 * 2.0) + -t65) + t245;
      t303 = -(t102 * ((t57 + t17 * t24 * 2.0) + -t58)) + t215;
      t304 = -(t102 * ((t60 + t17 * t25 * 2.0) + -t63)) + t216;
      t294 = t102 * (t71 + t75) + -t213;
      t297 = -(t102 * (t80 + t88)) + t35;
      t88 = -(t102 * (t84 + t88)) + -t214;
      t301 = t102 * ((t58 + t21 * t23 * 2.0) + -t57) + t253;
      t302 = t102 * ((t65 + t21 * t25 * 2.0) + -t67) + t36;
      t84 = t102 * ((t57 + t20 * t24 * 2.0) + -t58) + -t215;
      t80 = t102 * ((t60 + t20 * t25 * 2.0) + -t63) + -t216;
      t75 = -(t102 * ((t63 + t19 * t23 * 2.0) + -t60)) + -t217;
      t227 = -(t102 * ((t67 + t19 * t24 * 2.0) + -t65)) + -t245;
      t311 = ((-(t17 * t19 * t102 * 2.0) + t231) + -t232) + t218;
      t245 = ((-(t20 * t22 * t102 * 2.0) + t237) + -t238) + t218;
      t226 = ((-t102 * (t67 - t54 * 4.0) + t233) + t252) + -t289;
      t28 = ((-t102 * (t63 - t52 * 4.0) + t232) + -t237) + -t218;
      t27 = ((-t102 * (t58 - t50 * 4.0) + t247) + -t236) + -t287;
      t225 = ((-(t102 * (t65 + -(t55 * 4.0))) + t239) + t249) + -t289;
      t26 = ((-(t102 * (t60 + -(t53 * 4.0))) + t238) + -t231) + -t218;
      t103 = ((-(t102 * (t57 + -(t51 * 4.0))) + t250) + -t230) + -t287;
      t104 = (((-(t102 * (t56 + t62)) + t234) + t240) + t279) + -t283;
      t218 = (((-(t102 * (t56 + t70)) + t248) + t251) + t279) + -t282;
      t217 = (((-(t102 * (t62 + t70)) + -t229) + -t235) + t279) + -t281;
      t216 = t102 * (t71 + t79) + -t35;
      t215 = -(t102 * ((t58 + t18 * t23 * 2.0) + -t57)) + -t253;
      t214 = -(t102 * ((t65 + t18 * t25 * 2.0) + -t67)) + -t36;
      t213 = ((-(t17 * t18 * t102 * 2.0) + t230) + -t247) + t287;
      t37 = ((-(t20 * t21 * t102 * 2.0) + t236) + -t250) + t287;
      t36 = ((-(t18 * t19 * t102 * 2.0) + -t233) + -t249) + t289;
      t35 = ((-(t21 * t22 * t102 * 2.0) + -t239) + -t252) + t289;
      H.val(0) = t102 * (t46 + t48);
      H.val(1) = t162;
      H.val(2) = t163;
      H.val(3) = t88;
      H.val(4) = t84;
      H.val(5) = t80;
      H.val(6) = t293;
      H.val(7) = t303;
      H.val(8) = t304;
      H.val(9) = t162;
      H.val(10) = t102 * (t44 + t48);
      H.val(11) = t164;
      H.val(12) = t301;
      H.val(13) = t297;
      H.val(14) = t302;
      H.val(15) = t215;
      H.val(16) = t216;
      H.val(17) = t214;
      H.val(18) = t163;
      H.val(19) = t164;
      H.val(20) = t102 * (t44 + t46);
      H.val(21) = t299;
      H.val(22) = t300;
      H.val(23) = t295;
      H.val(24) = t75;
      H.val(25) = t227;
      H.val(26) = t294;
      H.val(27) = t88;
      H.val(28) = t301;
      H.val(29) = t299;
      H.val(30) = ((t235 * 2.0 + -t279) + t281) + t102 * (t42 + t43);
      H.val(31) = t37;
      H.val(32) = t245;
      H.val(33) = t217;
      H.val(34) = t27;
      H.val(35) = t28;
      H.val(36) = t84;
      H.val(37) = t297;
      H.val(38) = t300;
      H.val(39) = t37;
      H.val(40) = ((t251 * -2.0 + -t279) + t282) + t102 * (t41 + t43);
      H.val(41) = t35;
      H.val(42) = t103;
      H.val(43) = t218;
      H.val(44) = t226;
      H.val(45) = t80;
      H.val(46) = t302;
      H.val(47) = t295;
      H.val(48) = t245;
      H.val(49) = t35;
      H.val(50) = ((t240 * -2.0 + -t279) + t283) + t102 * (t41 + t42);
      H.val(51) = t26;
      H.val(52) = t225;
      H.val(53) = t104;
      H.val(54) = t293;
      H.val(55) = t215;
      H.val(56) = t75;
      H.val(57) = t217;
      H.val(58) = t103;
      H.val(59) = t26;
      H.val(60) = ((t229 * 2.0 + -t279) + t281) + t102 * (t39 + t40);
      H.val(61) = t213;
      H.val(62) = t311;
      H.val(63) = t303;
      H.val(64) = t216;
      H.val(65) = t227;
      H.val(66) = t27;
      H.val(67) = t218;
      H.val(68) = t225;
      H.val(69) = t213;
      H.val(70) = ((t248 * -2.0 + -t279) + t282) + t102 * (t38 + t40);
      H.val(71) = t36;
      H.val(72) = t304;
      H.val(73) = t214;
      H.val(74) = t294;
      H.val(75) = t28;
      H.val(76) = t226;
      H.val(77) = t104;
      H.val(78) = t311;
      H.val(79) = t36;
      H.val(80) = ((t234 * -2.0 + -t279) + t283) + t102 * (t38 + t39);
    }
  }  // namespace detail

  template <
      typename VecTP, typename VecTE,
      enable_if_all<VecTP::dim == 1, is_same_v<typename VecTP::dims, typename VecTE::dims>> = 0>
  constexpr int pe_distance_type(const VecInterface<VecTP> &p, const VecInterface<VecTE> &e0,
                                 const VecInterface<VecTE> &e1) noexcept {
    const auto e = e1 - e0;
    auto indicator = e.dot(p - e0) / e.l2NormSqr();
    return indicator < 0 ? 0 : (indicator > 1 ? 1 : 2);
  }

  template <
      typename VecTP, typename VecTE,
      enable_if_all<VecTP::dim == 1, is_same_v<typename VecTP::dims, typename VecTE::dims>> = 0>
  constexpr auto dist2_pe(const VecInterface<VecTP> &p, const VecInterface<VecTE> &e0,
                          const VecInterface<VecTE> &e1) noexcept {
    using T = math::op_result_t<typename VecTP::value_type, typename VecTE::value_type>;
    constexpr int dim = VecTP::extent;
    T dist2{0};
    if constexpr (dim == 1) {
      auto d0 = p[0] - e0[0];
      auto d1 = p[0] - e1[0];
      dist2 = d0 * d1 < 0 ? 0 : zs::min(d0 * d0, d1 * d1);
    } else if constexpr (dim == 2) {
      auto e = e1 - e0;
      auto numerator = (e[1] * p[0] - e[0] * p[1] + e1[0] * e0[1] - e1[1] * e0[0]);
      dist2 = numerator * numerator / e.l2NormSqr();
    } else if constexpr (dim == 3)
      dist2 = (e0 - p).cross(e1 - p).l2NormSqr() / (e1 - e0).l2NormSqr();
    return dist2;
  }

  template <
      typename VecTP, typename VecTE,
      enable_if_all<VecTP::dim == 1, is_same_v<typename VecTP::dims, typename VecTE::dims>> = 0>
  constexpr auto dist2_pe_unclassified(const VecInterface<VecTP> &p, const VecInterface<VecTE> &e0,
                                       const VecInterface<VecTE> &e1) noexcept {
    using T = math::op_result_t<typename VecTP::value_type, typename VecTE::value_type>;
    constexpr int dim = VecTP::extent;
    T ret = limits<T>::max();
    switch (pe_distance_type(p, e0, e1)) {
      case 0:
        ret = dist2_pp(p, e0);
        break;
      case 1:
        ret = dist2_pp(p, e1);
        break;
      case 2:
        if constexpr (dim == 2) {
          const auto e = e1 - e0;
          auto numerator = e[1] * p[0] - e[0] * p[1] + e1[0] * e0[1] - e1[1] * e0[0];
          ret = numerator * numerator / e.l2NormSqr();
        } else if constexpr (dim == 3) {
          ret = cross(e0 - p, e1 - p).l2NormSqr() / (e1 - e0).l2NormSqr();
        }
        break;
      default:
        break;
    }
    return ret;
  }
  template <
      typename VecTP, typename VecTE,
      enable_if_all<VecTP::dim == 1, is_same_v<typename VecTP::dims, typename VecTE::dims>> = 0>
  constexpr auto dist_pe_unclassified(const VecInterface<VecTP> &p, const VecInterface<VecTE> &e0,
                                      const VecInterface<VecTE> &e1) noexcept {
    return zs::sqrt(dist2_pe_unclassified(p, e0, e1));
  }

  template <
      typename VecTP, typename VecTE,
      enable_if_all<VecTP::dim == 1, is_same_v<typename VecTP::dims, typename VecTE::dims>> = 0>
  constexpr auto dist_grad_pe(const VecInterface<VecTP> &p, const VecInterface<VecTE> &e0,
                              const VecInterface<VecTE> &e1) noexcept {
    using T = math::op_result_t<typename VecTP::value_type, typename VecTE::value_type>;
    using Ti = typename VecTP::index_type;
    constexpr int dim = VecTP::extent;
    static_assert(dim == 3 || dim == 2, "currently only implement 2d/3d version");
    using GradT = typename VecTP::template variant_vec<T, integer_seq<Ti, 3, dim>>;
    GradT grad{};
    if constexpr (dim == 2)
      detail::g_PE2D(p[0], p[1], e0[0], e0[1], e1[0], e1[1], grad);
    else if constexpr (dim == 3)
      detail::g_PE3D(p[0], p[1], p[2], e0[0], e0[1], e0[2], e1[0], e1[1], e1[2], grad);
    return grad;
  }

  template <
      typename VecTP, typename VecTE,
      enable_if_all<VecTP::dim == 1, is_same_v<typename VecTP::dims, typename VecTE::dims>> = 0>
  constexpr auto dist_hess_pe(const VecInterface<VecTP> &p, const VecInterface<VecTE> &e0,
                              const VecInterface<VecTE> &e1) noexcept {
    using T = math::op_result_t<typename VecTP::value_type, typename VecTE::value_type>;
    using Ti = typename VecTP::index_type;
    constexpr int dim = VecTP::extent;
    static_assert(dim == 3 || dim == 2, "currently only implement 2d/3d version");
    using HessT = typename VecTP::template variant_vec<T, integer_seq<Ti, dim * 3, dim * 3>>;
    HessT hess{};
    if constexpr (dim == 2)
      detail::H_PE2D(p[0], p[1], e0[0], e0[1], e1[0], e1[1], hess);
    else if constexpr (dim == 3)
      detail::H_PE3D(p[0], p[1], p[2], e0[0], e0[1], e0[2], e1[0], e1[1], e1[2], hess);
    return hess;
  }

  //
  //! edge-edge
  //
  namespace detail {
    template <class T, typename VecT> constexpr void g_EE(T v01, T v02, T v03, T v11, T v12, T v13,
                                                          T v21, T v22, T v23, T v31, T v32, T v33,
                                                          VecInterface<VecT> &g) noexcept {
      T t11{};
      T t12{};
      T t13{};
      T t14{};
      T t15{};
      T t16{};
      T t17{};
      T t18{};
      T t19{};
      T t32{};
      T t33{};
      T t34{};
      T t35{};
      T t36{};
      T t37{};
      T t44{};
      T t45{};
      T t46{};
      T t75{};
      T t77{};
      T t76{};
      T t78{};
      T t79{};
      T t80{};
      T t81{};
      T t83{};

      /* G_EE */
      /*     G = G_EE(V01,V02,V03,V11,V12,V13,V21,V22,V23,V31,V32,V33) */
      /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
      /*     14-Jun-2019 13:58:25 */
      t11 = -v11 + v01;
      t12 = -v12 + v02;
      t13 = -v13 + v03;
      t14 = -v21 + v01;
      t15 = -v22 + v02;
      t16 = -v23 + v03;
      t17 = -v31 + v21;
      t18 = -v32 + v22;
      t19 = -v33 + v23;
      t32 = t14 * t18;
      t33 = t15 * t17;
      t34 = t14 * t19;
      t35 = t16 * t17;
      t36 = t15 * t19;
      t37 = t16 * t18;
      t44 = t11 * t18 + -(t12 * t17);
      t45 = t11 * t19 + -(t13 * t17);
      t46 = t12 * t19 + -(t13 * t18);
      t75 = 1.0 / ((t44 * t44 + t45 * t45) + t46 * t46);
      t77 = (t16 * t44 + t14 * t46) + -(t15 * t45);
      t76 = t75 * t75;
      t78 = t77 * t77;
      t79 = (t12 * t44 * 2.0 + t13 * t45 * 2.0) * t76 * t78;
      t80 = (t11 * t45 * 2.0 + t12 * t46 * 2.0) * t76 * t78;
      t81 = (t18 * t44 * 2.0 + t19 * t45 * 2.0) * t76 * t78;
      t18 = (t17 * t45 * 2.0 + t18 * t46 * 2.0) * t76 * t78;
      t83 = (t11 * t44 * 2.0 + -(t13 * t46 * 2.0)) * t76 * t78;
      t19 = (t17 * t44 * 2.0 + -(t19 * t46 * 2.0)) * t76 * t78;
      t76 = t75 * t77;
      g.val(0) = -t81 + t76 * ((-t36 + t37) + t46) * 2.0;
      g.val(1) = t19 - t76 * ((-t34 + t35) + t45) * 2.0;
      g.val(2) = t18 + t76 * ((-t32 + t33) + t44) * 2.0;
      g.val(3) = t81 + t76 * (t36 - t37) * 2.0;
      g.val(4) = -t19 - t76 * (t34 - t35) * 2.0;
      g.val(5) = -t18 + t76 * (t32 - t33) * 2.0;
      t17 = t12 * t16 + -(t13 * t15);
      g.val(6) = t79 - t76 * (t17 + t46) * 2.0;
      t18 = t11 * t16 + -(t13 * t14);
      g.val(7) = -t83 + t76 * (t18 + t45) * 2.0;
      t19 = t11 * t15 + -(t12 * t14);
      g.val(8) = -t80 - t76 * (t19 + t44) * 2.0;
      g.val(9) = -t79 + t76 * t17 * 2.0;
      g.val(10) = t83 - t76 * t18 * 2.0;
      g.val(11) = t80 + t76 * t19 * 2.0;
    }
    template <typename T, typename VecT> constexpr void H_EE(T v01, T v02, T v03, T v11, T v12,
                                                             T v13, T v21, T v22, T v23, T v31,
                                                             T v32, T v33, VecInterface<VecT> &H) {
      T t11{};
      T t12{};
      T t13{};
      T t14{};
      T t15{};
      T t16{};
      T t26{};
      T t27{};
      T t28{};
      T t47{};
      T t48{};
      T t49{};
      T t50{};
      T t51{};
      T t52{};
      T t53{};
      T t54{};
      T t55{};
      T t56{};
      T t57{};
      T t58{};
      T t59{};
      T t65{};
      T t73{};
      T t35{};
      T t36{};
      T t37{};
      T t38{};
      T t39{};
      T t40{};
      T t98{};
      T t99{};
      T t100{};
      T t101{};
      T t103{};
      T t105{};
      T t107{};
      T t108{};
      T t109{};
      T t137{};
      T t138{};
      T t139{};
      T t140{};
      T t141{};
      T t142{};
      T t143{};
      T t144{};
      T t145{};
      T t146{};
      T t147{};
      T t148{};
      T t156{};
      T t159{};
      T t157{};
      T t262{};
      T t263{};
      T t264{};
      T t265{};
      T t266{};
      T t267{};
      T t268{};
      T t269{};
      T t270{};
      T t271{};
      T t272{};
      T t273{};
      T t274{};
      T t275{};
      T t276{};
      T t277{};
      T t278{};
      T t279{};
      T t298{};
      T t299{};
      T t300{};
      T t301{};
      T t302{};
      T t303{};
      T t310{};
      T t311{};
      T t312{};
      T t313{};
      T t314{};
      T t315{};
      T t322{};
      T t323{};
      T t325{};
      T t326{};
      T t327{};
      T t328{};
      T t329{};
      T t330{};
      T t335{};
      T t337{};
      T t339{};
      T t340{};
      T t341{};
      T t342{};
      T t343{};
      T t345{};
      T t348{};
      T t353{};
      T t356{};
      T t358{};
      T t359{};
      T t360{};
      T t362{};
      T t367{};
      T t368{};
      T t369{};
      T t371{};
      T t374{};
      T t377{};
      T t382{};
      T t386{};
      T t387{};
      T t398{};
      T t399{};
      T t403{};
      T t408{};
      T t423{};
      T t424{};
      T t427{};
      T t428{};
      T t431{};
      T t432{};
      T t433{};
      T t434{};
      T t437{};
      T t438{};
      T t441{};
      T t442{};
      T t446{};
      T t451{};
      T t455{};
      T t456{};
      T t467{};
      T t468{};
      T t472{};
      T t477{};
      T t491{};
      T t492{};
      T t495{};
      T t497{};
      T t499{};
      T t500{};
      T t503{};
      T t504{};
      T t506{};
      T t508{};
      T t550{};
      T t568{};
      T t519_tmp{};
      T b_t519_tmp{};
      T t519{};
      T t520_tmp{};
      T b_t520_tmp{};
      T t520{};
      T t521_tmp{};
      T b_t521_tmp{};
      T t521{};
      T t522_tmp{};
      T b_t522_tmp{};
      T t522{};
      T t523_tmp{};
      T b_t523_tmp{};
      T t523{};
      T t524_tmp{};
      T b_t524_tmp{};
      T t524{};
      T t525{};
      T t526{};
      T t527{};
      T t528{};
      T t529{};
      T t530{};
      T t531{};
      T t532{};
      T t533{};
      T t534{};
      T t535{};
      T t536{};
      T t537{};
      T t538{};
      T t539{};
      T t540{};
      T t542{};
      T t543{};
      T t544{};

      /* H_EE */
      /*     H = H_EE(V01,V02,V03,V11,V12,V13,V21,V22,V23,V31,V32,V33) */
      /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
      /*     14-Jun-2019 13:58:38 */
      t11 = -v11 + v01;
      t12 = -v12 + v02;
      t13 = -v13 + v03;
      t14 = -v21 + v01;
      t15 = -v22 + v02;
      t16 = -v23 + v03;
      t26 = -v31 + v21;
      t27 = -v32 + v22;
      t28 = -v33 + v23;
      t47 = t11 * t27;
      t48 = t12 * t26;
      t49 = t11 * t28;
      t50 = t13 * t26;
      t51 = t12 * t28;
      t52 = t13 * t27;
      t53 = t14 * t27;
      t54 = t15 * t26;
      t55 = t14 * t28;
      t56 = t16 * t26;
      t57 = t15 * t28;
      t58 = t16 * t27;
      t59 = t11 * t26 * 2.0;
      t65 = t12 * t27 * 2.0;
      t73 = t13 * t28 * 2.0;
      t35 = t11 * t11 * 2.0;
      t36 = t12 * t12 * 2.0;
      t37 = t13 * t13 * 2.0;
      t38 = t26 * t26 * 2.0;
      t39 = t27 * t27 * 2.0;
      t40 = t28 * t28 * 2.0;
      t98 = t11 * t15 + -(t12 * t14);
      t99 = t11 * t16 + -(t13 * t14);
      t100 = t12 * t16 + -(t13 * t15);
      t101 = t47 + -t48;
      t103 = t49 + -t50;
      t105 = t51 + -t52;
      t107 = t53 + -t54;
      t108 = t55 + -t56;
      t109 = t57 + -t58;
      t137 = t98 + t101;
      t138 = t99 + t103;
      t139 = t100 + t105;
      t140 = (t54 + -t53) + t101;
      t141 = (t56 + -t55) + t103;
      t142 = (t58 + -t57) + t105;
      t143 = t12 * t101 * 2.0 + t13 * t103 * 2.0;
      t144 = t11 * t103 * 2.0 + t12 * t105 * 2.0;
      t145 = t27 * t101 * 2.0 + t28 * t103 * 2.0;
      t146 = t26 * t103 * 2.0 + t27 * t105 * 2.0;
      t147 = t11 * t101 * 2.0 + -(t13 * t105 * 2.0);
      t148 = t26 * t101 * 2.0 + -(t28 * t105 * 2.0);
      t156 = 1.0 / ((t101 * t101 + t103 * t103) + t105 * t105);
      t159 = (t16 * t101 + t14 * t105) + -(t15 * t103);
      t157 = t156 * t156;
      // t57 = pow(t156, 3.0);
      t57 = t156 * t156 * t156;
      t58 = t159 * t159;
      t262 = t11 * t156 * t159 * 2.0;
      t263 = t12 * t156 * t159 * 2.0;
      t264 = t13 * t156 * t159 * 2.0;
      t265 = t14 * t156 * t159 * 2.0;
      t266 = t15 * t156 * t159 * 2.0;
      t267 = t16 * t156 * t159 * 2.0;
      t268 = (-v31 + v01) * t156 * t159 * 2.0;
      t269 = (-v21 + v11) * t156 * t159 * 2.0;
      t270 = (-v32 + v02) * t156 * t159 * 2.0;
      t271 = (-v22 + v12) * t156 * t159 * 2.0;
      t272 = (-v33 + v03) * t156 * t159 * 2.0;
      t273 = (-v23 + v13) * t156 * t159 * 2.0;
      t274 = (-v31 + v11) * t156 * t159 * 2.0;
      t275 = (-v32 + v12) * t156 * t159 * 2.0;
      t276 = (-v33 + v13) * t156 * t159 * 2.0;
      t277 = t26 * t156 * t159 * 2.0;
      t278 = t27 * t156 * t159 * 2.0;
      t279 = t28 * t156 * t159 * 2.0;
      t298 = t11 * t12 * t157 * t58 * 2.0;
      t299 = t11 * t13 * t157 * t58 * 2.0;
      t300 = t12 * t13 * t157 * t58 * 2.0;
      t301 = t26 * t27 * t157 * t58 * 2.0;
      t302 = t26 * t28 * t157 * t58 * 2.0;
      t303 = t27 * t28 * t157 * t58 * 2.0;
      t310 = (t35 + t36) * t157 * t58;
      t311 = (t35 + t37) * t157 * t58;
      t312 = (t36 + t37) * t157 * t58;
      t313 = (t38 + t39) * t157 * t58;
      t314 = (t38 + t40) * t157 * t58;
      t315 = (t39 + t40) * t157 * t58;
      t322 = (t59 + t65) * t157 * t58;
      t323 = (t59 + t73) * t157 * t58;
      t59 = (t65 + t73) * t157 * t58;
      t325 = (t47 * 2.0 + -(t48 * 4.0)) * t157 * t58;
      t53 = -t157 * t58;
      t56 = t48 * 2.0 - t47 * 4.0;
      t326 = t53 * t56;
      t327 = (t49 * 2.0 + -(t50 * 4.0)) * t157 * t58;
      t55 = t50 * 2.0 - t49 * 4.0;
      t328 = t53 * t55;
      t329 = (t51 * 2.0 + -(t52 * 4.0)) * t157 * t58;
      t54 = t52 * 2.0 - t51 * 4.0;
      t330 = t53 * t54;
      t53 = t157 * t58;
      t335 = t53 * t56;
      t337 = t53 * t55;
      t339 = t53 * t54;
      t340 = t143 * t143 * t57 * t58 * 2.0;
      t341 = t144 * t144 * t57 * t58 * 2.0;
      t342 = t145 * t145 * t57 * t58 * 2.0;
      t343 = t146 * t146 * t57 * t58 * 2.0;
      t345 = t147 * t147 * t57 * t58 * 2.0;
      t348 = t148 * t148 * t57 * t58 * 2.0;
      t36 = t98 * t143 * t157 * t159 * 2.0;
      t353 = t99 * t143 * t157 * t159 * 2.0;
      t356 = t99 * t144 * t157 * t159 * 2.0;
      t65 = t100 * t144 * t157 * t159 * 2.0;
      t358 = t107 * t143 * t157 * t159 * 2.0;
      t359 = t98 * t145 * t157 * t159 * 2.0;
      t360 = t108 * t143 * t157 * t159 * 2.0;
      t54 = t107 * t144 * t157 * t159 * 2.0;
      t362 = t99 * t145 * t157 * t159 * 2.0;
      t53 = t98 * t146 * t157 * t159 * 2.0;
      t56 = t109 * t143 * t157 * t159 * 2.0;
      t27 = t108 * t144 * t157 * t159 * 2.0;
      t55 = t100 * t145 * t157 * t159 * 2.0;
      t367 = t99 * t146 * t157 * t159 * 2.0;
      t368 = t109 * t144 * t157 * t159 * 2.0;
      t369 = t100 * t146 * t157 * t159 * 2.0;
      t38 = t107 * t145 * t157 * t159 * 2.0;
      t371 = t108 * t145 * t157 * t159 * 2.0;
      t374 = t108 * t146 * t157 * t159 * 2.0;
      t28 = t109 * t146 * t157 * t159 * 2.0;
      t377 = t98 * t147 * t157 * t159 * 2.0;
      t382 = t100 * t147 * t157 * t159 * 2.0;
      t386 = t107 * t147 * t157 * t159 * 2.0;
      t387 = t98 * t148 * t157 * t159 * 2.0;
      t103 = t108 * t147 * t157 * t159 * 2.0;
      t101 = t99 * t148 * t157 * t159 * 2.0;
      t398 = t109 * t147 * t157 * t159 * 2.0;
      t399 = t100 * t148 * t157 * t159 * 2.0;
      t403 = t107 * t148 * t157 * t159 * 2.0;
      t408 = t109 * t148 * t157 * t159 * 2.0;
      t73 = t137 * t143 * t157 * t159 * 2.0;
      t423 = t138 * t143 * t157 * t159 * 2.0;
      t424 = t138 * t144 * t157 * t159 * 2.0;
      t37 = t139 * t144 * t157 * t159 * 2.0;
      t427 = t140 * t143 * t157 * t159 * 2.0;
      t428 = t137 * t145 * t157 * t159 * 2.0;
      t16 = t140 * t144 * t157 * t159 * 2.0;
      t11 = t137 * t146 * t157 * t159 * 2.0;
      t431 = t141 * t143 * t157 * t159 * 2.0;
      t432 = t138 * t145 * t157 * t159 * 2.0;
      t433 = t141 * t144 * t157 * t159 * 2.0;
      t434 = t138 * t146 * t157 * t159 * 2.0;
      t105 = t142 * t143 * t157 * t159 * 2.0;
      t14 = t139 * t145 * t157 * t159 * 2.0;
      t437 = t142 * t144 * t157 * t159 * 2.0;
      t438 = t139 * t146 * t157 * t159 * 2.0;
      t35 = t140 * t145 * t157 * t159 * 2.0;
      t441 = t141 * t145 * t157 * t159 * 2.0;
      t442 = t141 * t146 * t157 * t159 * 2.0;
      t39 = t142 * t146 * t157 * t159 * 2.0;
      t446 = t137 * t147 * t157 * t159 * 2.0;
      t451 = t139 * t147 * t157 * t159 * 2.0;
      t455 = t140 * t147 * t157 * t159 * 2.0;
      t456 = t137 * t148 * t157 * t159 * 2.0;
      t13 = t141 * t147 * t157 * t159 * 2.0;
      t26 = t138 * t148 * t157 * t159 * 2.0;
      t467 = t142 * t147 * t157 * t159 * 2.0;
      t468 = t139 * t148 * t157 * t159 * 2.0;
      t472 = t140 * t148 * t157 * t159 * 2.0;
      t477 = t142 * t148 * t157 * t159 * 2.0;
      t47 = t143 * t144 * t57 * t58 * 2.0;
      t15 = t143 * t145 * t57 * t58 * 2.0;
      t491 = t143 * t146 * t57 * t58 * 2.0;
      t492 = t144 * t145 * t57 * t58 * 2.0;
      t12 = t144 * t146 * t57 * t58 * 2.0;
      t40 = t145 * t146 * t57 * t58 * 2.0;
      t495 = t143 * t147 * t57 * t58 * 2.0;
      t497 = t144 * t147 * t57 * t58 * 2.0;
      t499 = t143 * t148 * t57 * t58 * 2.0;
      t500 = t145 * t147 * t57 * t58 * 2.0;
      t503 = t146 * t147 * t57 * t58 * 2.0;
      t504 = t144 * t148 * t57 * t58 * 2.0;
      t506 = t145 * t148 * t57 * t58 * 2.0;
      t508 = t146 * t148 * t57 * t58 * 2.0;
      t57 = t147 * t148 * t57 * t58 * 2.0;
      t550 = ((((t98 * t109 * t156 * 2.0 + -t266) + t337) + t359) + t368) + t492;
      t568 = ((((t108 * t137 * t156 * 2.0 + -t268) + t330) + t27) + t456) + t504;
      t519_tmp = t139 * t143 * t157 * t159;
      b_t519_tmp = t100 * t143 * t157 * t159;
      t519 = (((-(t100 * t139 * t156 * 2.0) + t312) + -t340) + b_t519_tmp * 2.0) + t519_tmp * 2.0;
      t520_tmp = t140 * t146 * t157 * t159;
      b_t520_tmp = t107 * t146 * t157 * t159;
      t520 = (((t107 * t140 * t156 * 2.0 + t313) + -t343) + b_t520_tmp * 2.0) + -(t520_tmp * 2.0);
      t521_tmp = t142 * t145 * t157 * t159;
      b_t521_tmp = t109 * t145 * t157 * t159;
      t521 = (((t109 * t142 * t156 * 2.0 + t315) + -t342) + -(b_t521_tmp * 2.0)) + t521_tmp * 2.0;
      t522_tmp = t137 * t144 * t157 * t159;
      b_t522_tmp = t98 * t144 * t157 * t159;
      t522 = (((-(t98 * t137 * t156 * 2.0) + t310) + -t341) + -(b_t522_tmp * 2.0))
             + -(t522_tmp * 2.0);
      t523_tmp = t138 * t147 * t157 * t159;
      b_t523_tmp = t99 * t147 * t157 * t159;
      t523 = (((-(t99 * t138 * t156 * 2.0) + t311) + -t345) + b_t523_tmp * 2.0) + t523_tmp * 2.0;
      t524_tmp = t141 * t148 * t157 * t159;
      b_t524_tmp = t108 * t148 * t157 * t159;
      t524 = (((t108 * t141 * t156 * 2.0 + t314) + -t348) + -(b_t524_tmp * 2.0)) + t524_tmp * 2.0;
      t525 = (((t98 * t100 * t156 * 2.0 + t299) + t65) + -t36) + -t47;
      t526 = (((t107 * t109 * t156 * 2.0 + t302) + t38) + -t28) + -t40;
      t527 = (((-(t98 * t99 * t156 * 2.0) + t300) + t377) + -t356) + t497;
      t528 = (((-(t99 * t100 * t156 * 2.0) + t298) + t353) + t382) + -t495;
      t529 = (((-(t107 * t108 * t156 * 2.0) + t303) + t374) + -t403) + t508;
      t530 = (((-(t108 * t109 * t156 * 2.0) + t301) + -t371) + -t408) + -t506;
      t531 = (((t98 * t107 * t156 * 2.0 + t322) + t54) + -t53) + -t12;
      t532 = (((t100 * t109 * t156 * 2.0 + t59) + t55) + -t56) + -t15;
      t533 = (((t99 * t108 * t156 * 2.0 + t323) + t101) + -t103) + -t57;
      t534 = (((t98 * t140 * t156 * 2.0 + -t322) + t53) + t16) + t12;
      t535 = (((-(t107 * t137 * t156 * 2.0) + -t322) + -t54) + t11) + t12;
      t536 = (((t100 * t142 * t156 * 2.0 + -t59) + -t55) + -t105) + t15;
      t537 = (((-(t109 * t139 * t156 * 2.0) + -t59) + t56) + -t14) + t15;
      t538 = (((t99 * t141 * t156 * 2.0 + -t323) + -t101) + -t13) + t57;
      t539 = (((-(t108 * t138 * t156 * 2.0) + -t323) + t103) + -t26) + t57;
      t540 = (((t137 * t139 * t156 * 2.0 + t299) + t37) + -t73) + -t47;
      t148 = (((t140 * t142 * t156 * 2.0 + t302) + t39) + -t35) + -t40;
      t542 = (((-(t137 * t138 * t156 * 2.0) + t300) + t446) + -t424) + t497;
      t543 = (((-(t138 * t139 * t156 * 2.0) + t298) + t423) + t451) + -t495;
      t544 = (((-(t140 * t141 * t156 * 2.0) + t303) + t472) + -t442) + t508;
      t53 = (((-(t141 * t142 * t156 * 2.0) + t301) + t441) + t477) + -t506;
      t157 = (((-(t139 * t142 * t156 * 2.0) + t59) + t105) + t14) + -t15;
      t159 = (((-(t137 * t140 * t156 * 2.0) + t322) + -t16) + -t11) + -t12;
      t147 = (((-(t138 * t141 * t156 * 2.0) + t323) + t13) + t26) + -t57;
      t146 = ((((t100 * t107 * t156 * 2.0 + t266) + t327) + -t358) + -t369) + t491;
      t145 = ((((-(t99 * t107 * t156 * 2.0) + -t265) + t329) + t367) + t386) + -t503;
      t144 = ((((-(t100 * t108 * t156 * 2.0) + -t267) + t325) + t360) + -t399) + t499;
      t143 = ((((-(t99 * t109 * t156 * 2.0) + t267) + t335) + -t362) + t398) + t500;
      t52 = ((((-(t98 * t108 * t156 * 2.0) + t265) + t339) + -t27) + -t387) + -t504;
      t51 = ((((t109 * t140 * t156 * 2.0 + -t278) + -t302) + t28) + t35) + t40;
      t50 = ((((-(t98 * t139 * t156 * 2.0) + t263) + -t299) + t36) + -t37) + t47;
      t49 = ((((t107 * t142 * t156 * 2.0 + t278) + -t302) + -t38) + -t39) + t40;
      t48 = ((((-(t100 * t137 * t156 * 2.0) + -t263) + -t299) + -t65) + t73) + t47;
      t47 = ((((t99 * t137 * t156 * 2.0 + t262) + -t300) + t356) + -t446) + -t497;
      t73 = ((((t100 * t138 * t156 * 2.0 + t264) + -t298) + -t382) + -t423) + t495;
      t65 = ((((-(t109 * t141 * t156 * 2.0) + t279) + -t301) + t408) + -t441) + t506;
      t59 = ((((t98 * t138 * t156 * 2.0 + -t262) + -t300) + -t377) + t424) + -t497;
      t40 = ((((t99 * t139 * t156 * 2.0 + -t264) + -t298) + -t353) + -t451) + t495;
      t39 = ((((-(t107 * t141 * t156 * 2.0) + -t277) + -t303) + t403) + t442) + -t508;
      t38 = ((((-(t108 * t142 * t156 * 2.0) + -t279) + -t301) + t371) + -t477) + t506;
      t37 = ((((-(t108 * t140 * t156 * 2.0) + t277) + -t303) + -t374) + -t472) + -t508;
      t36 = ((((t98 * t142 * t156 * 2.0 + t271) + t328) + -t359) + t437) + -t492;
      t35 = ((((-(t109 * t137 * t156 * 2.0) + t270) + t328) + -t368) + -t428) + -t492;
      t28 = ((((t100 * t140 * t156 * 2.0 + -t271) + -t327) + t369) + -t427) + -t491;
      t27 = ((((-(t98 * t141 * t156 * 2.0) + -t269) + t330) + t387) + -t433) + t504;
      t26 = ((((t109 * t138 * t156 * 2.0 + -t272) + t326) + -t398) + t432) + -t500;
      t13 = ((((-(t107 * t139 * t156 * 2.0) + -t270) + -t327) + t358) + t438) + -t491;
      t12 = ((((-(t99 * t142 * t156 * 2.0) + -t273) + t326) + t362) + t467) + -t500;
      t11 = ((((-(t99 * t140 * t156 * 2.0) + t269) + -t329) + -t367) + t455) + t503;
      t16 = ((((t107 * t138 * t156 * 2.0 + t268) + -t329) + -t386) + -t434) + t503;
      t15 = ((((-(t100 * t141 * t156 * 2.0) + t273) + -t325) + t399) + t431) + -t499;
      t14 = ((((t108 * t139 * t156 * 2.0 + t272) + -t325) + -t360) + t468) + -t499;
      t105 = ((((-(t139 * t140 * t156 * 2.0) + t275) + t327) + t427) + -t438) + t491;
      t103 = ((((t138 * t140 * t156 * 2.0 + -t274) + t329) + t434) + -t455) + -t503;
      t101 = ((((-(t137 * t142 * t156 * 2.0) + -t275) + t337) + t428) + -t437) + t492;
      t58 = ((((t139 * t141 * t156 * 2.0 + -t276) + t325) + -t431) + -t468) + t499;
      t57 = ((((t137 * t141 * t156 * 2.0 + t274) + t339) + t433) + -t456) + -t504;
      t56 = ((((t138 * t142 * t156 * 2.0 + t276) + t335) + -t432) + -t467) + t500;
      t55 = -t315 + t342;
      H.val(0) = (t55 + t142 * t142 * t156 * 2.0) - t521_tmp * 4.0;
      H.val(1) = t53;
      H.val(2) = t148;
      H.val(3) = t521;
      H.val(4) = t38;
      H.val(5) = t49;
      H.val(6) = t157;
      H.val(7) = t56;
      H.val(8) = t101;
      H.val(9) = t536;
      H.val(10) = t12;
      H.val(11) = t36;
      H.val(12) = t53;
      t54 = -t314 + t348;
      H.val(13) = (t54 + t141 * t141 * t156 * 2.0) - t524_tmp * 4.0;
      H.val(14) = t544;
      H.val(15) = t65;
      H.val(16) = t524;
      H.val(17) = t39;
      H.val(18) = t58;
      H.val(19) = t147;
      H.val(20) = t57;
      H.val(21) = t15;
      H.val(22) = t538;
      H.val(23) = t27;
      H.val(24) = t148;
      H.val(25) = t544;
      t53 = -t313 + t343;
      H.val(26) = (t53 + t140 * t140 * t156 * 2.0) + t520_tmp * 4.0;
      H.val(27) = t51;
      H.val(28) = t37;
      H.val(29) = t520;
      H.val(30) = t105;
      H.val(31) = t103;
      H.val(32) = t159;
      H.val(33) = t28;
      H.val(34) = t11;
      H.val(35) = t534;
      H.val(36) = t521;
      H.val(37) = t65;
      H.val(38) = t51;
      H.val(39) = (t55 + t109 * t109 * t156 * 2.0) + b_t521_tmp * 4.0;
      H.val(40) = t530;
      H.val(41) = t526;
      H.val(42) = t537;
      H.val(43) = t26;
      H.val(44) = t35;
      H.val(45) = t532;
      H.val(46) = t143;
      H.val(47) = t550;
      H.val(48) = t38;
      H.val(49) = t524;
      H.val(50) = t37;
      H.val(51) = t530;
      H.val(52) = (t54 + t108 * t108 * t156 * 2.0) + b_t524_tmp * 4.0;
      H.val(53) = t529;
      H.val(54) = t14;
      H.val(55) = t539;
      H.val(56) = t568;
      H.val(57) = t144;
      H.val(58) = t533;
      H.val(59) = t52;
      H.val(60) = t49;
      H.val(61) = t39;
      H.val(62) = t520;
      H.val(63) = t526;
      H.val(64) = t529;
      H.val(65) = (t53 + t107 * t107 * t156 * 2.0) - b_t520_tmp * 4.0;
      H.val(66) = t13;
      H.val(67) = t16;
      H.val(68) = t535;
      H.val(69) = t146;
      H.val(70) = t145;
      H.val(71) = t531;
      H.val(72) = t157;
      H.val(73) = t58;
      H.val(74) = t105;
      H.val(75) = t537;
      H.val(76) = t14;
      H.val(77) = t13;
      t55 = -t312 + t340;
      H.val(78) = (t55 + t139 * t139 * t156 * 2.0) - t519_tmp * 4.0;
      H.val(79) = t543;
      H.val(80) = t540;
      H.val(81) = t519;
      H.val(82) = t40;
      H.val(83) = t50;
      H.val(84) = t56;
      H.val(85) = t147;
      H.val(86) = t103;
      H.val(87) = t26;
      H.val(88) = t539;
      H.val(89) = t16;
      H.val(90) = t543;
      t54 = -t311 + t345;
      H.val(91) = (t54 + t138 * t138 * t156 * 2.0) - t523_tmp * 4.0;
      H.val(92) = t542;
      H.val(93) = t73;
      H.val(94) = t523;
      H.val(95) = t59;
      H.val(96) = t101;
      H.val(97) = t57;
      H.val(98) = t159;
      H.val(99) = t35;
      H.val(100) = t568;
      H.val(101) = t535;
      H.val(102) = t540;
      H.val(103) = t542;
      t53 = -t310 + t341;
      H.val(104) = (t53 + t137 * t137 * t156 * 2.0) + t522_tmp * 4.0;
      H.val(105) = t48;
      H.val(106) = t47;
      H.val(107) = t522;
      H.val(108) = t536;
      H.val(109) = t15;
      H.val(110) = t28;
      H.val(111) = t532;
      H.val(112) = t144;
      H.val(113) = t146;
      H.val(114) = t519;
      H.val(115) = t73;
      H.val(116) = t48;
      H.val(117) = (t55 + t100 * t100 * t156 * 2.0) - b_t519_tmp * 4.0;
      H.val(118) = t528;
      H.val(119) = t525;
      H.val(120) = t12;
      H.val(121) = t538;
      H.val(122) = t11;
      H.val(123) = t143;
      H.val(124) = t533;
      H.val(125) = t145;
      H.val(126) = t40;
      H.val(127) = t523;
      H.val(128) = t47;
      H.val(129) = t528;
      H.val(130) = (t54 + t99 * t99 * t156 * 2.0) - b_t523_tmp * 4.0;
      H.val(131) = t527;
      H.val(132) = t36;
      H.val(133) = t27;
      H.val(134) = t534;
      H.val(135) = t550;
      H.val(136) = t52;
      H.val(137) = t531;
      H.val(138) = t50;
      H.val(139) = t59;
      H.val(140) = t522;
      H.val(141) = t525;
      H.val(142) = t527;
      H.val(143) = (t53 + t98 * t98 * t156 * 2.0) + b_t522_tmp * 4.0;
    }
  }  // namespace detail

  template <typename VecTA, typename VecTB>
  constexpr int ee_distance_type(const VecInterface<VecTA> &ea0, const VecInterface<VecTA> &ea1,
                                 const VecInterface<VecTB> &eb0, const VecInterface<VecTB> &eb1) {
    using T = math::op_result_t<typename VecTA::value_type, typename VecTB::value_type>;
    auto u = ea1 - ea0;
    auto v = eb1 - eb0;
    auto w = ea0 - eb0;
    T a = u.l2NormSqr();  // always >= 0
    T b = u.dot(v);
    T c = v.l2NormSqr();  // always >= 0
    T d = u.dot(w);
    T e = v.dot(w);
    T D = a * c - b * b;  // always >= 0
    T tD = D;             // tc = tN / tD, default tD = D >= 0
    T sN{}, tN{};

    int defaultCase = 8;

    // compute the line parameters of the two closest points
    sN = (b * e - c * d);
    if (sN <= 0) {  // sc < 0 => the s=0 edge is visible
      tN = e;
      tD = c;
      defaultCase = 2;
    } else if (sN >= D) {  // sc > 1  => the s=1 edge is visible
      tN = e + b;
      tD = c;
      defaultCase = 5;
    } else {
      tN = (a * e - b * d);
      if (tN > 0 && tN < tD
          && (u.cross(v).dot(w) == 0 || u.cross(v).l2NormSqr() < 1.0e-20 * a * c)) {
        if (sN < D / 2) {
          tN = e;
          tD = c;
          defaultCase = 2;
        } else {
          tN = e + b;
          tD = c;
          defaultCase = 5;
        }
      }
      // else defaultCase stays as 8
    }

    if (tN <= 0) {  // tc < 0 => the t=0 edge is visible
      // recompute sc for this edge
      if (-d <= 0) {
        return 0;
      } else if (-d >= a) {
        return 3;
      } else {
        return 6;
      }
    } else if (tN >= tD) {  // tc > 1  => the t=1 edge is visible
      // recompute sc for this edge
      if ((-d + b) <= 0) {
        return 1;
      } else if ((-d + b) >= a) {
        return 4;
      } else {
        return 7;
      }
    }

    return defaultCase;
  }

  template <
      typename VecTA, typename VecTB,
      enable_if_all<VecTA::dim == 1, is_same_v<typename VecTA::dims, typename VecTB::dims>> = 0>
  constexpr auto dist2_ee(const VecInterface<VecTA> &ea0, const VecInterface<VecTA> &ea1,
                          const VecInterface<VecTB> &eb0, const VecInterface<VecTB> &eb1) noexcept {
    using T = math::op_result_t<typename VecTA::value_type, typename VecTB::value_type>;
    auto b = (ea1 - ea0).cross(eb1 - eb0);
    T aTb = (eb0 - ea0).dot(b);
    return aTb * aTb / b.l2NormSqr();
  }

  template <
      typename VecTA, typename VecTB,
      enable_if_all<VecTA::dim == 1, is_same_v<typename VecTA::dims, typename VecTB::dims>> = 0>
  constexpr auto dist2_ee_unclassified(const VecInterface<VecTA> &ea0,
                                       const VecInterface<VecTA> &ea1,
                                       const VecInterface<VecTB> &eb0,
                                       const VecInterface<VecTB> &eb1) noexcept {
    using T = math::op_result_t<typename VecTA::value_type, typename VecTB::value_type>;
    T dist2{limits<T>::max()};
    switch (ee_distance_type(ea0, ea1, eb0, eb1)) {
      case 0:
        dist2 = dist2_pp(ea0, eb0);
        break;
      case 1:
        dist2 = dist2_pp(ea0, eb1);
        break;
      case 2:
        dist2 = dist2_pe(ea0, eb0, eb1);
        break;
      case 3:
        dist2 = dist2_pp(ea1, eb0);
        break;
      case 4:
        dist2 = dist2_pp(ea1, eb1);
        break;
      case 5:
        dist2 = dist2_pe(ea1, eb0, eb1);
        break;
      case 6:
        dist2 = dist2_pe(eb0, ea0, ea1);
        break;
      case 7:
        dist2 = dist2_pe(eb1, ea0, ea1);
        break;
      case 8:
        dist2 = dist2_ee(ea0, ea1, eb0, eb1);
        break;
      default:
        break;
    }
    return dist2;
  }

  template <
      typename VecTA, typename VecTB,
      enable_if_all<VecTA::dim == 1, is_same_v<typename VecTA::dims, typename VecTB::dims>> = 0>
  constexpr auto dist_ee_unclassified(const VecInterface<VecTA> &ea0,
                                      const VecInterface<VecTA> &ea1,
                                      const VecInterface<VecTB> &eb0,
                                      const VecInterface<VecTB> &eb1) noexcept {
    return zs::sqrt(dist2_ee_unclassified(ea0, ea1, eb0, eb1));
  }

  template <
      typename VecTA, typename VecTB,
      enable_if_all<VecTA::dim == 1, is_same_v<typename VecTA::dims, typename VecTB::dims>> = 0>
  constexpr auto dist_grad_ee(const VecInterface<VecTA> &ea0, const VecInterface<VecTA> &ea1,
                              const VecInterface<VecTB> &eb0,
                              const VecInterface<VecTB> &eb1) noexcept {
    using T = math::op_result_t<typename VecTA::value_type, typename VecTB::value_type>;
    using Ti = typename VecTA::index_type;
    constexpr int dim = VecTA::template range_t<0>::value;
    static_assert(dim == 3, "currently only implement 3d version");
    using GradT = typename VecTA::template variant_vec<T, integer_seq<Ti, 4, dim>>;
    GradT grad{};
    detail::g_EE(ea0[0], ea0[1], ea0[2], ea1[0], ea1[1], ea1[2], eb0[0], eb0[1], eb0[2], eb1[0],
                 eb1[1], eb1[2], grad);
    return grad;
  }

  template <
      typename VecTA, typename VecTB,
      enable_if_all<VecTA::dim == 1, is_same_v<typename VecTA::dims, typename VecTB::dims>> = 0>
  constexpr auto dist_hess_ee(const VecInterface<VecTA> &ea0, const VecInterface<VecTA> &ea1,
                              const VecInterface<VecTB> &eb0,
                              const VecInterface<VecTB> &eb1) noexcept {
    using T = math::op_result_t<typename VecTA::value_type, typename VecTB::value_type>;
    using Ti = typename VecTA::index_type;
    constexpr int dim = VecTA::template range_t<0>::value;
    static_assert(dim == 3, "currently only implement 3d version");
    using HessT = typename VecTA::template variant_vec<T, integer_seq<Ti, dim * 4, dim * 4>>;
    HessT hess{};
    detail::H_EE(ea0[0], ea0[1], ea0[2], ea1[0], ea1[1], ea1[2], eb0[0], eb0[1], eb0[2], eb1[0],
                 eb1[1], eb1[2], hess);
    return hess;
  }

  //
  //! edge-edge mollifier
  // ref: bow/codim-ipc
  //
  namespace detail {

    template <typename T> constexpr T EEM(T input, T eps_x) {
      T input_div_eps_x = input / eps_x;
      return (-input_div_eps_x + 2) * input_div_eps_x;
    }

    template <typename T> constexpr T g_EEM(T input, T eps_x) {
      T one_div_eps_x = 1 / eps_x;
      return 2 * one_div_eps_x * (-one_div_eps_x * input + 1);
    }

    template <typename T> constexpr T H_EEM(T input, T eps_x) { return -2 / (eps_x * eps_x); }

    template <typename T, typename VecT> void g_EECN2(T v01, T v02, T v03, T v11, T v12, T v13,
                                                      T v21, T v22, T v23, T v31, T v32, T v33,
                                                      VecInterface<VecT> &g) {
      T t8{};
      T t9{};
      T t10{};
      T t11{};
      T t12{};
      T t13{};
      T t23{};
      T t24{};
      T t25{};
      T t26{};
      T t27{};
      T t28{};
      T t29{};
      T t30{};
      T t31{};
      T t32{};
      T t33{};

      /* COMPUTEEECROSSSQNORMGRADIENT */
      /*     G = COMPUTEEECROSSSQNORMGRADIENT(V01,V02,V03,V11,V12,V13,V21,V22,V23,V31,V32,V33) */
      /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
      /*     01-Nov-2019 16:54:23 */
      t8 = -v11 + v01;
      t9 = -v12 + v02;
      t10 = -v13 + v03;
      t11 = -v31 + v21;
      t12 = -v32 + v22;
      t13 = -v33 + v23;
      t23 = t8 * t12 + -(t9 * t11);
      t24 = t8 * t13 + -(t10 * t11);
      t25 = t9 * t13 + -(t10 * t12);
      t26 = t8 * t23 * 2.0;
      t27 = t9 * t23 * 2.0;
      t28 = t8 * t24 * 2.0;
      t29 = t10 * t24 * 2.0;
      t30 = t9 * t25 * 2.0;
      t31 = t10 * t25 * 2.0;
      t32 = t11 * t23 * 2.0;
      t33 = t12 * t23 * 2.0;
      t23 = t11 * t24 * 2.0;
      t10 = t13 * t24 * 2.0;
      t9 = t12 * t25 * 2.0;
      t8 = t13 * t25 * 2.0;
      g.val(0) = t33 + t10;
      g.val(1) = -t32 + t8;
      g.val(2) = -t23 - t9;
      g.val(3) = -t33 - t10;
      g.val(4) = t32 - t8;
      g.val(5) = t23 + t9;
      g.val(6) = -t27 - t29;
      g.val(7) = t26 - t31;
      g.val(8) = t28 + t30;
      g.val(9) = t27 + t29;
      g.val(10) = -t26 + t31;
      g.val(11) = -t28 - t30;
    }

    template <typename T, typename VecT>
    constexpr void H_EECN2(T v01, T v02, T v03, T v11, T v12, T v13, T v21, T v22, T v23, T v31,
                           T v32, T v33, VecInterface<VecT> &H) {
      T t8{};
      T t9{};
      T t10{};
      T t11{};
      T t12{};
      T t13{};
      T t32{};
      T t33{};
      T t34{};
      T t35{};
      T t48{};
      T t36{};
      T t49{};
      T t37{};
      T t38{};
      T t39{};
      T t40{};
      T t41{};
      T t42{};
      T t43{};
      T t44{};
      T t45{};
      T t46{};
      T t47{};
      T t50{};
      T t51{};
      T t52{};
      T t20{};
      T t23{};
      T t24{};
      T t25{};
      T t86{};
      T t87{};
      T t88{};
      T t74{};
      T t75{};
      T t76{};
      T t77{};
      T t78{};
      T t79{};
      T t89{};
      T t90{};
      T t91{};
      T t92{};
      T t93{};
      T t94{};
      T t95{};

      /* COMPUTEEECROSSSQNORMHESSIAN */
      /*     H = COMPUTEEECROSSSQNORMHESSIAN(V01,V02,V03,V11,V12,V13,V21,V22,V23,V31,V32,V33) */
      /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
      /*     01-Nov-2019 16:54:23 */
      t8 = -v11 + v01;
      t9 = -v12 + v02;
      t10 = -v13 + v03;
      t11 = -v31 + v21;
      t12 = -v32 + v22;
      t13 = -v33 + v23;
      t32 = t8 * t9 * 2.0;
      t33 = t8 * t10 * 2.0;
      t34 = t9 * t10 * 2.0;
      t35 = t8 * t11 * 2.0;
      t48 = t8 * t12;
      t36 = t48 * 2.0;
      t49 = t9 * t11;
      t37 = t49 * 2.0;
      t38 = t48 * 4.0;
      t48 = t8 * t13;
      t39 = t48 * 2.0;
      t40 = t49 * 4.0;
      t41 = t9 * t12 * 2.0;
      t49 = t10 * t11;
      t42 = t49 * 2.0;
      t43 = t48 * 4.0;
      t48 = t9 * t13;
      t44 = t48 * 2.0;
      t45 = t49 * 4.0;
      t49 = t10 * t12;
      t46 = t49 * 2.0;
      t47 = t48 * 4.0;
      t48 = t49 * 4.0;
      t49 = t10 * t13 * 2.0;
      t50 = t11 * t12 * 2.0;
      t51 = t11 * t13 * 2.0;
      t52 = t12 * t13 * 2.0;
      t20 = t8 * t8 * 2.0;
      t9 = t9 * t9 * 2.0;
      t8 = t10 * t10 * 2.0;
      t23 = t11 * t11 * 2.0;
      t24 = t12 * t12 * 2.0;
      t25 = t13 * t13 * 2.0;
      t86 = t35 + t41;
      t87 = t35 + t49;
      t88 = t41 + t49;
      t74 = t20 + t9;
      t75 = t20 + t8;
      t76 = t9 + t8;
      t77 = t23 + t24;
      t78 = t23 + t25;
      t79 = t24 + t25;
      t89 = t40 + -t36;
      t90 = t36 + -t40;
      t91 = t37 + -t38;
      t92 = t38 + -t37;
      t93 = t45 + -t39;
      t94 = t39 + -t45;
      t95 = t42 + -t43;
      t37 = t43 + -t42;
      t39 = t48 + -t44;
      t45 = t44 + -t48;
      t38 = t46 + -t47;
      t40 = t47 + -t46;
      t36 = -t35 + -t41;
      t13 = -t35 + -t49;
      t11 = -t41 + -t49;
      t12 = -t20 + -t9;
      t10 = -t20 + -t8;
      t8 = -t9 + -t8;
      t9 = -t23 + -t24;
      t49 = -t23 + -t25;
      t48 = -t24 + -t25;
      H.val(0) = t79;
      H.val(1) = -t50;
      H.val(2) = -t51;
      H.val(3) = t48;
      H.val(4) = t50;
      H.val(5) = t51;
      H.val(6) = t11;
      H.val(7) = t92;
      H.val(8) = t37;
      H.val(9) = t88;
      H.val(10) = t91;
      H.val(11) = t95;
      H.val(12) = -t50;
      H.val(13) = t78;
      H.val(14) = -t52;
      H.val(15) = t50;
      H.val(16) = t49;
      H.val(17) = t52;
      H.val(18) = t89;
      H.val(19) = t13;
      H.val(20) = t40;
      H.val(21) = t90;
      H.val(22) = t87;
      H.val(23) = t38;
      H.val(24) = -t51;
      H.val(25) = -t52;
      H.val(26) = t77;
      H.val(27) = t51;
      H.val(28) = t52;
      H.val(29) = t9;
      H.val(30) = t93;
      H.val(31) = t39;
      H.val(32) = t36;
      H.val(33) = t94;
      H.val(34) = t45;
      H.val(35) = t86;
      H.val(36) = t48;
      H.val(37) = t50;
      H.val(38) = t51;
      H.val(39) = t79;
      H.val(40) = -t50;
      H.val(41) = -t51;
      H.val(42) = t88;
      H.val(43) = t91;
      H.val(44) = t95;
      H.val(45) = t11;
      H.val(46) = t92;
      H.val(47) = t37;
      H.val(48) = t50;
      H.val(49) = t49;
      H.val(50) = t52;
      H.val(51) = -t50;
      H.val(52) = t78;
      H.val(53) = -t52;
      H.val(54) = t90;
      H.val(55) = t87;
      H.val(56) = t38;
      H.val(57) = t89;
      H.val(58) = t13;
      H.val(59) = t40;
      H.val(60) = t51;
      H.val(61) = t52;
      H.val(62) = t9;
      H.val(63) = -t51;
      H.val(64) = -t52;
      H.val(65) = t77;
      H.val(66) = t94;
      H.val(67) = t45;
      H.val(68) = t86;
      H.val(69) = t93;
      H.val(70) = t39;
      H.val(71) = t36;
      H.val(72) = t11;
      H.val(73) = t89;
      H.val(74) = t93;
      H.val(75) = t88;
      H.val(76) = t90;
      H.val(77) = t94;
      H.val(78) = t76;
      H.val(79) = -t32;
      H.val(80) = -t33;
      H.val(81) = t8;
      H.val(82) = t32;
      H.val(83) = t33;
      H.val(84) = t92;
      H.val(85) = t13;
      H.val(86) = t39;
      H.val(87) = t91;
      H.val(88) = t87;
      H.val(89) = t45;
      H.val(90) = -t32;
      H.val(91) = t75;
      H.val(92) = -t34;
      H.val(93) = t32;
      H.val(94) = t10;
      H.val(95) = t34;
      H.val(96) = t37;
      H.val(97) = t40;
      H.val(98) = t36;
      H.val(99) = t95;
      H.val(100) = t38;
      H.val(101) = t86;
      H.val(102) = -t33;
      H.val(103) = -t34;
      H.val(104) = t74;
      H.val(105) = t33;
      H.val(106) = t34;
      H.val(107) = t12;
      H.val(108) = t88;
      H.val(109) = t90;
      H.val(110) = t94;
      H.val(111) = t11;
      H.val(112) = t89;
      H.val(113) = t93;
      H.val(114) = t8;
      H.val(115) = t32;
      H.val(116) = t33;
      H.val(117) = t76;
      H.val(118) = -t32;
      H.val(119) = -t33;
      H.val(120) = t91;
      H.val(121) = t87;
      H.val(122) = t45;
      H.val(123) = t92;
      H.val(124) = t13;
      H.val(125) = t39;
      H.val(126) = t32;
      H.val(127) = t10;
      H.val(128) = t34;
      H.val(129) = -t32;
      H.val(130) = t75;
      H.val(131) = -t34;
      H.val(132) = t95;
      H.val(133) = t38;
      H.val(134) = t86;
      H.val(135) = t37;
      H.val(136) = t40;
      H.val(137) = t36;
      H.val(138) = t33;
      H.val(139) = t34;
      H.val(140) = t12;
      H.val(141) = -t33;
      H.val(142) = -t34;
      H.val(143) = t74;
    }

  }  // namespace detail

  template <
      typename VecTA, typename VecTB,
      enable_if_all<VecTA::dim == 1, is_same_v<typename VecTA::dims, typename VecTB::dims>> = 0>
  constexpr auto cn2_ee(const VecInterface<VecTA> &ea0, const VecInterface<VecTA> &ea1,
                        const VecInterface<VecTB> &eb0, const VecInterface<VecTB> &eb1) noexcept {
    using T = math::op_result_t<typename VecTA::value_type, typename VecTB::value_type>;
    return (ea1 - ea0).cross(eb1 - eb0).l2NormSqr();
  }

  template <
      typename VecTA, typename VecTB,
      enable_if_all<VecTA::dim == 1, is_same_v<typename VecTA::dims, typename VecTB::dims>> = 0>
  constexpr auto cn2_grad_ee(const VecInterface<VecTA> &ea0, const VecInterface<VecTA> &ea1,
                             const VecInterface<VecTB> &eb0,
                             const VecInterface<VecTB> &eb1) noexcept {
    using T = math::op_result_t<typename VecTA::value_type, typename VecTB::value_type>;
    using Ti = typename VecTA::index_type;
    constexpr int dim = VecTA::template range_t<0>::value;
    static_assert(dim == 3, "currently only implement 3d version");
    using GradT = typename VecTA::template variant_vec<T, integer_seq<Ti, 4, dim>>;
    GradT grad{};
    detail::g_EECN2(ea0[0], ea0[1], ea0[2], ea1[0], ea1[1], ea1[2], eb0[0], eb0[1], eb0[2], eb1[0],
                    eb1[1], eb1[2], grad);
    return grad;
  }

  template <
      typename VecTA, typename VecTB,
      enable_if_all<VecTA::dim == 1, is_same_v<typename VecTA::dims, typename VecTB::dims>> = 0>
  constexpr auto cn2_hess_ee(const VecInterface<VecTA> &ea0, const VecInterface<VecTA> &ea1,
                             const VecInterface<VecTB> &eb0,
                             const VecInterface<VecTB> &eb1) noexcept {
    using T = math::op_result_t<typename VecTA::value_type, typename VecTB::value_type>;
    using Ti = typename VecTA::index_type;
    constexpr int dim = VecTA::template range_t<0>::value;
    static_assert(dim == 3, "currently only implement 3d version");
    using HessT = typename VecTA::template variant_vec<T, integer_seq<Ti, dim * 4, dim * 4>>;
    HessT hess{};
    detail::H_EECN2(ea0[0], ea0[1], ea0[2], ea1[0], ea1[1], ea1[2], eb0[0], eb0[1], eb0[2], eb1[0],
                    eb1[1], eb1[2], hess);
    return hess;
  }

  template <
      typename VecTA, typename VecTB,
      enable_if_all<VecTA::dim == 1, is_same_v<typename VecTA::dims, typename VecTB::dims>> = 0>
  constexpr auto mollifier_threshold_ee(const VecInterface<VecTA> &ea0Rest,
                                        const VecInterface<VecTA> &ea1Rest,
                                        const VecInterface<VecTB> &eb0Rest,
                                        const VecInterface<VecTB> &eb1Rest) noexcept {
    using T = math::op_result_t<typename VecTA::value_type, typename VecTB::value_type>;
    return (T)1e-3 * (ea0Rest - ea1Rest).l2NormSqr() * (eb0Rest - eb1Rest).l2NormSqr();
  }

  template <
      typename VecTA, typename VecTB,
      enable_if_all<VecTA::dim == 1, is_same_v<typename VecTA::dims, typename VecTB::dims>> = 0>
  constexpr auto mollifier_ee(const VecInterface<VecTA> &ea0, const VecInterface<VecTA> &ea1,
                              const VecInterface<VecTB> &eb0, const VecInterface<VecTB> &eb1,
                              typename VecTA::value_type eps) noexcept {
    using T = math::op_result_t<typename VecTA::value_type, typename VecTB::value_type>;
    auto c = cn2_ee(ea0, ea1, eb0, eb1);
    if (c < eps)
      return (T)detail::EEM(c, eps);
    else
      return (T)1;
  }

  template <
      typename VecTA, typename VecTB,
      enable_if_all<VecTA::dim == 1, is_same_v<typename VecTA::dims, typename VecTB::dims>> = 0>
  constexpr auto mollifier_grad_ee(const VecInterface<VecTA> &ea0, const VecInterface<VecTA> &ea1,
                                   const VecInterface<VecTB> &eb0, const VecInterface<VecTB> &eb1,
                                   typename VecTA::value_type eps) noexcept {
    using T = math::op_result_t<typename VecTA::value_type, typename VecTB::value_type>;
    using Ti = typename VecTA::index_type;
    constexpr int dim = VecTA::template range_t<0>::value;
    static_assert(dim == 3, "currently only implement 3d version");
    using GradT = typename VecTA::template variant_vec<T, integer_seq<Ti, 4, dim>>;

    auto c = cn2_ee(ea0, ea1, eb0, eb1);
    if (c < eps)
      return detail::g_EEM(c, eps) * cn2_grad_ee(ea0, ea1, eb0, eb1);
    else
      return GradT::zeros();
  }

  template <
      typename VecTA, typename VecTB,
      enable_if_all<VecTA::dim == 1, is_same_v<typename VecTA::dims, typename VecTB::dims>> = 0>
  constexpr auto mollifier_hess_ee(const VecInterface<VecTA> &ea0, const VecInterface<VecTA> &ea1,
                                   const VecInterface<VecTB> &eb0, const VecInterface<VecTB> &eb1,
                                   typename VecTA::value_type eps) noexcept {
    using T = math::op_result_t<typename VecTA::value_type, typename VecTB::value_type>;
    using Ti = typename VecTA::index_type;
    constexpr int dim = VecTA::template range_t<0>::value;
    static_assert(dim == 3, "currently only implement 3d version");
    using HessT = typename VecTA::template variant_vec<T, integer_seq<Ti, dim * 4, dim * 4>>;

    auto c = cn2_ee(ea0, ea1, eb0, eb1);
    if (c < eps) {
      auto g_eem = detail::g_EEM(c, eps);
      auto H_eem = detail::H_EEM(c, eps);
      auto g = cn2_grad_ee(ea0, ea1, eb0, eb1);
      HessT ggT{};  // dyadic_prod(g)
      for (Ti i = 0; i != dim * 4; ++i)
        for (Ti j = 0; j != dim * 4; ++j) ggT(i, j) = g.val(i) * g.val(j);
      return cn2_hess_ee(ea0, ea1, eb0, eb1) * g_eem + H_eem * ggT;
    } else
      return HessT::zeros();
  }

  //
  //! point-triangle
  //
  namespace detail {
    template <typename T, typename VecT>
    constexpr void g_PT(T v01, T v02, T v03, T v11, T v12, T v13, T v21, T v22, T v23, T v31, T v32,
                        T v33, VecInterface<VecT> &g) noexcept {
      T t11{};
      T t12{};
      T t13{};
      T t14{};
      T t15{};
      T t16{};
      T t17{};
      T t18{};
      T t19{};
      T t20{};
      T t21{};
      T t22{};
      T t32{};
      T t33{};
      T t34{};
      T t43{};
      T t45{};
      T t44{};
      T t46{};

      /* G_PT */
      /*     G = G_PT(V01,V02,V03,V11,V12,V13,V21,V22,V23,V31,V32,V33) */
      /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
      /*     10-Jun-2019 17:42:16 */
      t11 = -v11 + v01;
      t12 = -v12 + v02;
      t13 = -v13 + v03;
      t14 = -v21 + v11;
      t15 = -v22 + v12;
      t16 = -v23 + v13;
      t17 = -v31 + v11;
      t18 = -v32 + v12;
      t19 = -v33 + v13;
      t20 = -v31 + v21;
      t21 = -v32 + v22;
      t22 = -v33 + v23;
      t32 = t14 * t18 + -(t15 * t17);
      t33 = t14 * t19 + -(t16 * t17);
      t34 = t15 * t19 + -(t16 * t18);
      t43 = 1.0 / ((t32 * t32 + t33 * t33) + t34 * t34);
      t45 = (t13 * t32 + t11 * t34) + -(t12 * t33);
      t44 = t43 * t43;
      t46 = t45 * t45;
      g.val(0) = t34 * t43 * t45 * 2.0;
      g.val(1) = t33 * t43 * t45 * -2.0;
      g.val(2) = t32 * t43 * t45 * 2.0;
      t45 *= t43;
      g.val(3) = -t44 * t46 * (t21 * t32 * 2.0 + t22 * t33 * 2.0)
                 - t45 * ((t34 + t12 * t22) - t13 * t21) * 2.0;
      t43 = t44 * t46;
      g.val(4)
          = t43 * (t20 * t32 * 2.0 - t22 * t34 * 2.0) + t45 * ((t33 + t11 * t22) - t13 * t20) * 2.0;
      g.val(5)
          = t43 * (t20 * t33 * 2.0 + t21 * t34 * 2.0) - t45 * ((t32 + t11 * t21) - t12 * t20) * 2.0;
      g.val(6) = t45 * (t12 * t19 - t13 * t18) * 2.0 + t43 * (t18 * t32 * 2.0 + t19 * t33 * 2.0);
      g.val(7) = t45 * (t11 * t19 - t13 * t17) * -2.0 - t43 * (t17 * t32 * 2.0 - t19 * t34 * 2.0);
      g.val(8) = t45 * (t11 * t18 - t12 * t17) * 2.0 - t43 * (t17 * t33 * 2.0 + t18 * t34 * 2.0);
      g.val(9) = t45 * (t12 * t16 - t13 * t15) * -2.0 - t43 * (t15 * t32 * 2.0 + t16 * t33 * 2.0);
      g.val(10) = t45 * (t11 * t16 - t13 * t14) * 2.0 + t43 * (t14 * t32 * 2.0 - t16 * t34 * 2.0);
      g.val(11) = t45 * (t11 * t15 - t12 * t14) * -2.0 + t43 * (t14 * t33 * 2.0 + t15 * t34 * 2.0);
    }

    template <typename T, typename VecT> constexpr void H_PT(T v01, T v02, T v03, T v11, T v12,
                                                             T v13, T v21, T v22, T v23, T v31,
                                                             T v32, T v33, VecInterface<VecT> &H) {
      T t11{};
      T t12{};
      T t13{};
      T t18{};
      T t20{};
      T t22{};
      T t23{};
      T t24{};
      T t25{};
      T t26{};
      T t27{};
      T t28{};
      T t65{};
      T t66{};
      T t67{};
      T t68{};
      T t69{};
      T t70{};
      T t71{};
      T t77{};
      T t85{};
      T t86{};
      T t90{};
      T t94{};
      T t95{};
      T t99{};
      T t103{};
      T t38{};
      T t39{};
      T t40{};
      T t41{};
      T t42{};
      T t43{};
      T t44{};
      T t45{};
      T t46{};
      T t72{};
      T t73{};
      T t75{};
      T t78{};
      T t80{};
      T t82{};
      T t125{};
      T t126{};
      T t127{};
      T t128{};
      T t129{};
      T t130{};
      T t131{};
      T t133{};
      T t135{};
      T t149{};
      T t150{};
      T t151{};
      T t189{};
      T t190{};
      T t191{};
      T t192{};
      T t193{};
      T t194{};
      T t195{};
      T t196{};
      T t197{};
      T t198{};
      T t199{};
      T t200{};
      T t202{};
      T t205{};
      T t203{};
      T t204{};
      T t206{};
      T t241{};
      T t309{};
      T t310{};
      T t312{};
      T t313{};
      T t314{};
      T t315{};
      T t316{};
      T t317{};
      T t318{};
      T t319{};
      T t321{};
      T t322{};
      T t323{};
      T t324{};
      T t325{};
      T t261{};
      T t262{};
      T t599{};
      T t600{};
      T t602{};
      T t605{};
      T t609{};
      T t610{};
      T t611{};
      T t613{};
      T t615{};
      T t616{};
      T t621{};
      T t622{};
      T t623{};
      T t625{};
      T t645{};
      T t646_tmp{};
      T t646{};
      T t601{};
      T t603{};
      T t604{};
      T t606{};
      T t607{};
      T t608{};
      T t612{};
      T t614{};
      T t617{};
      T t618{};
      T t619{};
      T t620{};
      T t624{};
      T t626{};
      T t627{};
      T t628{};
      T t629{};
      T t630{};
      T t631{};
      T t632{};
      T t633{};
      T t634{};
      T t635{};
      T t636{};
      T t637{};
      T t638{};

      /* H_PT */
      /*     H = H_PT(V01,V02,V03,V11,V12,V13,V21,V22,V23,V31,V32,V33) */
      /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
      /*     10-Jun-2019 17:42:25 */
      t11 = -v11 + v01;
      t12 = -v12 + v02;
      t13 = -v13 + v03;
      t18 = -v21 + v11;
      t20 = -v22 + v12;
      t22 = -v23 + v13;
      t23 = -v31 + v11;
      t24 = -v32 + v12;
      t25 = -v33 + v13;
      t26 = -v31 + v21;
      t27 = -v32 + v22;
      t28 = -v33 + v23;
      t65 = t18 * t24;
      t66 = t20 * t23;
      t67 = t18 * t25;
      t68 = t22 * t23;
      t69 = t20 * t25;
      t70 = t22 * t24;
      t71 = t18 * t23 * 2.0;
      t77 = t20 * t24 * 2.0;
      t85 = t22 * t25 * 2.0;
      t86 = t18 * t26 * 2.0;
      t90 = t20 * t27 * 2.0;
      t94 = t22 * t28 * 2.0;
      t95 = t23 * t26 * 2.0;
      t99 = t24 * t27 * 2.0;
      t103 = t25 * t28 * 2.0;
      t38 = t18 * t18 * 2.0;
      t39 = t20 * t20 * 2.0;
      t40 = t22 * t22 * 2.0;
      t41 = t23 * t23 * 2.0;
      t42 = t24 * t24 * 2.0;
      t43 = t25 * t25 * 2.0;
      t44 = t26 * t26 * 2.0;
      t45 = t27 * t27 * 2.0;
      t46 = t28 * t28 * 2.0;
      t72 = t65 * 2.0;
      t73 = t66 * 2.0;
      t75 = t67 * 2.0;
      t78 = t68 * 2.0;
      t80 = t69 * 2.0;
      t82 = t70 * 2.0;
      t125 = t11 * t20 + -(t12 * t18);
      t126 = t11 * t22 + -(t13 * t18);
      t127 = t12 * t22 + -(t13 * t20);
      t128 = t11 * t24 + -(t12 * t23);
      t129 = t11 * t25 + -(t13 * t23);
      t130 = t12 * t25 + -(t13 * t24);
      t131 = t65 + -t66;
      t133 = t67 + -t68;
      t135 = t69 + -t70;
      t149 = t131 * t131;
      t150 = t133 * t133;
      t151 = t135 * t135;
      t189 = (t11 * t27 + -(t12 * t26)) + t131;
      t190 = (t11 * t28 + -(t13 * t26)) + t133;
      t191 = (t12 * t28 + -(t13 * t27)) + t135;
      t192 = t20 * t131 * 2.0 + t22 * t133 * 2.0;
      t193 = t18 * t133 * 2.0 + t20 * t135 * 2.0;
      t194 = t24 * t131 * 2.0 + t25 * t133 * 2.0;
      t195 = t23 * t133 * 2.0 + t24 * t135 * 2.0;
      t196 = t27 * t131 * 2.0 + t28 * t133 * 2.0;
      t197 = t26 * t133 * 2.0 + t27 * t135 * 2.0;
      t198 = t18 * t131 * 2.0 + -(t22 * t135 * 2.0);
      t199 = t23 * t131 * 2.0 + -(t25 * t135 * 2.0);
      t200 = t26 * t131 * 2.0 + -(t28 * t135 * 2.0);
      t202 = 1.0 / ((t149 + t150) + t151);
      t205 = (t13 * t131 + t11 * t135) + -(t12 * t133);
      t203 = t202 * t202;
      // t204 = pow(t202, 3.0);
      t204 = t202 * t202 * t202;
      t206 = t205 * t205;
      t241 = t131 * t135 * t202 * 2.0;
      t309 = t11 * t202 * t205 * 2.0;
      t310 = t12 * t202 * t205 * 2.0;
      t13 = t13 * t202 * t205 * 2.0;
      t312 = (-v21 + v01) * t202 * t205 * 2.0;
      t313 = (-v22 + v02) * t202 * t205 * 2.0;
      t314 = (-v23 + v03) * t202 * t205 * 2.0;
      t315 = (-v31 + v01) * t202 * t205 * 2.0;
      t316 = t18 * t202 * t205 * 2.0;
      t317 = (-v32 + v02) * t202 * t205 * 2.0;
      t318 = t20 * t202 * t205 * 2.0;
      t319 = (-v33 + v03) * t202 * t205 * 2.0;
      t11 = t22 * t202 * t205 * 2.0;
      t321 = t23 * t202 * t205 * 2.0;
      t322 = t24 * t202 * t205 * 2.0;
      t323 = t25 * t202 * t205 * 2.0;
      t324 = t26 * t202 * t205 * 2.0;
      t325 = t27 * t202 * t205 * 2.0;
      t12 = t28 * t202 * t205 * 2.0;
      t261 = -(t131 * t133 * t202 * 2.0);
      t262 = -(t133 * t135 * t202 * 2.0);
      t599 = t130 * t135 * t202 * 2.0 + t135 * t194 * t203 * t205 * 2.0;
      t600 = -(t125 * t131 * t202 * 2.0) + t131 * t193 * t203 * t205 * 2.0;
      t602 = t129 * t133 * t202 * 2.0 + t133 * t199 * t203 * t205 * 2.0;
      t605 = -(t131 * t189 * t202 * 2.0) + t131 * t197 * t203 * t205 * 2.0;
      t609 = (t127 * t133 * t202 * 2.0 + -t11) + t133 * t192 * t203 * t205 * 2.0;
      t610 = (t126 * t135 * t202 * 2.0 + t11) + t135 * t198 * t203 * t205 * 2.0;
      t611 = (t130 * t131 * t202 * 2.0 + -t322) + t131 * t194 * t203 * t205 * 2.0;
      t613 = (t126 * t131 * t202 * 2.0 + -t316) + t131 * t198 * t203 * t205 * 2.0;
      t615 = (-(t125 * t135 * t202 * 2.0) + -t318) + t135 * t193 * t203 * t205 * 2.0;
      t616 = (-(t128 * t133 * t202 * 2.0) + -t321) + t133 * t195 * t203 * t205 * 2.0;
      t621 = (t133 * t191 * t202 * 2.0 + -t12) + t133 * t196 * t203 * t205 * 2.0;
      t622 = (t135 * t190 * t202 * 2.0 + t12) + t135 * t200 * t203 * t205 * 2.0;
      t623 = (t131 * t190 * t202 * 2.0 + -t324) + t131 * t200 * t203 * t205 * 2.0;
      t625 = (-(t135 * t189 * t202 * 2.0) + -t325) + t135 * t197 * t203 * t205 * 2.0;
      t645 = ((((t127 * t129 * t202 * 2.0 + -t13) + (t72 + -(t66 * 4.0)) * t203 * t206)
               + t129 * t192 * t203 * t205 * 2.0)
              + t127 * t199 * t203 * t205 * 2.0)
             + t192 * t199 * t204 * t206 * 2.0;
      t646_tmp = t203 * t206;
      t646 = ((((t126 * t130 * t202 * 2.0 + t13) + t646_tmp * (t73 - t65 * 4.0))
               + t126 * t194 * t203 * t205 * 2.0)
              + t130 * t198 * t203 * t205 * 2.0)
             + t194 * t198 * t204 * t206 * 2.0;
      t601 = t128 * t131 * t202 * 2.0 + -(t131 * t195 * t203 * t205 * 2.0);
      t603 = -(t127 * t135 * t202 * 2.0) + -(t135 * t192 * t203 * t205 * 2.0);
      t604 = -(t126 * t133 * t202 * 2.0) + -(t133 * t198 * t203 * t205 * 2.0);
      t606 = -(t135 * t191 * t202 * 2.0) + -(t135 * t196 * t203 * t205 * 2.0);
      t607 = -(t133 * t190 * t202 * 2.0) + -(t133 * t200 * t203 * t205 * 2.0);
      t608 = (t125 * t133 * t202 * 2.0 + t316) + -(t133 * t193 * t203 * t205 * 2.0);
      t612 = (t128 * t135 * t202 * 2.0 + t322) + -(t135 * t195 * t203 * t205 * 2.0);
      t614 = (-(t127 * t131 * t202 * 2.0) + t318) + -(t131 * t192 * t203 * t205 * 2.0);
      t617 = (-(t130 * t133 * t202 * 2.0) + t323) + -(t133 * t194 * t203 * t205 * 2.0);
      t618 = (-(t129 * t131 * t202 * 2.0) + t321) + -(t131 * t199 * t203 * t205 * 2.0);
      t619 = (-(t129 * t135 * t202 * 2.0) + -t323) + -(t135 * t199 * t203 * t205 * 2.0);
      t620 = (t133 * t189 * t202 * 2.0 + t324) + -(t133 * t197 * t203 * t205 * 2.0);
      t624 = (-(t131 * t191 * t202 * 2.0) + t325) + -(t131 * t196 * t203 * t205 * 2.0);
      t626 = (((t125 * t127 * t202 * 2.0 + t18 * t22 * t203 * t206 * 2.0)
               + t125 * t192 * t203 * t205 * 2.0)
              + -(t127 * t193 * t203 * t205 * 2.0))
             + -(t192 * t193 * t204 * t206 * 2.0);
      t627 = (((t128 * t130 * t202 * 2.0 + t23 * t25 * t203 * t206 * 2.0)
               + t128 * t194 * t203 * t205 * 2.0)
              + -(t130 * t195 * t203 * t205 * 2.0))
             + -(t194 * t195 * t204 * t206 * 2.0);
      t628 = (((-(t125 * t126 * t202 * 2.0) + t20 * t22 * t203 * t206 * 2.0)
               + t126 * t193 * t203 * t205 * 2.0)
              + -(t125 * t198 * t203 * t205 * 2.0))
             + t193 * t198 * t204 * t206 * 2.0;
      t629 = (((-(t128 * t129 * t202 * 2.0) + t24 * t25 * t203 * t206 * 2.0)
               + t129 * t195 * t203 * t205 * 2.0)
              + -(t128 * t199 * t203 * t205 * 2.0))
             + t195 * t199 * t204 * t206 * 2.0;
      t630 = (((-(t126 * t127 * t202 * 2.0) + t18 * t20 * t203 * t206 * 2.0)
               + -(t126 * t192 * t203 * t205 * 2.0))
              + -(t127 * t198 * t203 * t205 * 2.0))
             + -(t192 * t198 * t204 * t206 * 2.0);
      t631 = (((-(t129 * t130 * t202 * 2.0) + t23 * t24 * t203 * t206 * 2.0)
               + -(t129 * t194 * t203 * t205 * 2.0))
              + -(t130 * t199 * t203 * t205 * 2.0))
             + -(t194 * t199 * t204 * t206 * 2.0);
      t632 = (((-(t125 * t128 * t202 * 2.0) + (t71 + t77) * t203 * t206)
               + t128 * t193 * t203 * t205 * 2.0)
              + t125 * t195 * t203 * t205 * 2.0)
             + -(t193 * t195 * t204 * t206 * 2.0);
      t633 = (((-(t127 * t130 * t202 * 2.0) + (t77 + t85) * t203 * t206)
               + -(t130 * t192 * t203 * t205 * 2.0))
              + -(t127 * t194 * t203 * t205 * 2.0))
             + -(t192 * t194 * t204 * t206 * 2.0);
      t634 = (((-(t126 * t129 * t202 * 2.0) + (t71 + t85) * t203 * t206)
               + -(t129 * t198 * t203 * t205 * 2.0))
              + -(t126 * t199 * t203 * t205 * 2.0))
             + -(t198 * t199 * t204 * t206 * 2.0);
      t635 = (((t127 * t191 * t202 * 2.0 + -((t90 + t94) * t203 * t206))
               + t127 * t196 * t203 * t205 * 2.0)
              + t191 * t192 * t203 * t205 * 2.0)
             + t192 * t196 * t204 * t206 * 2.0;
      t636 = (((-(t128 * t189 * t202 * 2.0) + (t95 + t99) * t203 * t206)
               + t128 * t197 * t203 * t205 * 2.0)
              + t189 * t195 * t203 * t205 * 2.0)
             + -(t195 * t197 * t204 * t206 * 2.0);
      t637 = (((t125 * t189 * t202 * 2.0 + -((t86 + t90) * t203 * t206))
               + -(t125 * t197 * t203 * t205 * 2.0))
              + -(t189 * t193 * t203 * t205 * 2.0))
             + t193 * t197 * t204 * t206 * 2.0;
      t638 = (((-(t130 * t191 * t202 * 2.0) + (t99 + t103) * t203 * t206)
               + -(t130 * t196 * t203 * t205 * 2.0))
              + -(t191 * t194 * t203 * t205 * 2.0))
             + -(t194 * t196 * t204 * t206 * 2.0);
      t86 = (((t126 * t190 * t202 * 2.0 + -((t86 + t94) * t203 * t206))
              + t126 * t200 * t203 * t205 * 2.0)
             + t190 * t198 * t203 * t205 * 2.0)
            + t198 * t200 * t204 * t206 * 2.0;
      t71 = (((-(t129 * t190 * t202 * 2.0) + (t95 + t103) * t203 * t206)
              + -(t129 * t200 * t203 * t205 * 2.0))
             + -(t190 * t199 * t203 * t205 * 2.0))
            + -(t199 * t200 * t204 * t206 * 2.0);
      t85 = (((t189 * t191 * t202 * 2.0 + t26 * t28 * t203 * t206 * 2.0)
              + t189 * t196 * t203 * t205 * 2.0)
             + -(t191 * t197 * t203 * t205 * 2.0))
            + -(t196 * t197 * t204 * t206 * 2.0);
      t90 = (((-(t189 * t190 * t202 * 2.0) + t27 * t28 * t203 * t206 * 2.0)
              + t190 * t197 * t203 * t205 * 2.0)
             + -(t189 * t200 * t203 * t205 * 2.0))
            + t197 * t200 * t204 * t206 * 2.0;
      t99 = (((-(t190 * t191 * t202 * 2.0) + t26 * t27 * t203 * t206 * 2.0)
              + -(t190 * t196 * t203 * t205 * 2.0))
             + -(t191 * t200 * t203 * t205 * 2.0))
            + -(t196 * t200 * t204 * t206 * 2.0);
      t77 = ((((-(t127 * t128 * t202 * 2.0) + t310) + (t75 + -(t68 * 4.0)) * t203 * t206)
              + t127 * t195 * t203 * t205 * 2.0)
             + -(t128 * t192 * t203 * t205 * 2.0))
            + t192 * t195 * t204 * t206 * 2.0;
      t131 = ((((t126 * t128 * t202 * 2.0 + -t309) + (t80 + -(t70 * 4.0)) * t203 * t206)
               + t128 * t198 * t203 * t205 * 2.0)
              + -(t126 * t195 * t203 * t205 * 2.0))
             + -(t195 * t198 * t204 * t206 * 2.0);
      t133 = ((((-(t125 * t130 * t202 * 2.0) + -t310) + t646_tmp * (t78 - t67 * 4.0))
               + t130 * t193 * t203 * t205 * 2.0)
              + -(t125 * t194 * t203 * t205 * 2.0))
             + t193 * t194 * t204 * t206 * 2.0;
      t325 = ((((t125 * t129 * t202 * 2.0 + t309) + t646_tmp * (t82 - t69 * 4.0))
               + t125 * t199 * t203 * t205 * 2.0)
              + -(t129 * t193 * t203 * t205 * 2.0))
             + -(t193 * t199 * t204 * t206 * 2.0);
      t135 = ((((t125 * t191 * t202 * 2.0 + t313) + ((t75 + t18 * t28 * 2.0) + -t78) * t203 * t206)
               + t125 * t196 * t203 * t205 * 2.0)
              + -(t191 * t193 * t203 * t205 * 2.0))
             + -(t193 * t196 * t204 * t206 * 2.0);
      t324 = ((((t127 * t189 * t202 * 2.0 + -t313) + ((t78 + t22 * t26 * 2.0) + -t75) * t203 * t206)
               + -(t127 * t197 * t203 * t205 * 2.0))
              + t189 * t192 * t203 * t205 * 2.0)
             + -(t192 * t197 * t204 * t206 * 2.0);
      t318 = ((((-(t126 * t189 * t202 * 2.0) + t312)
                + ((t82 + t22 * t27 * 2.0) + -t80) * t203 * t206)
               + t126 * t197 * t203 * t205 * 2.0)
              + -(t189 * t198 * t203 * t205 * 2.0))
             + t197 * t198 * t204 * t206 * 2.0;
      t321 = ((((-(t130 * t189 * t202 * 2.0) + t317)
                + -(((t78 + t25 * t26 * 2.0) + -t75) * t203 * t206))
               + t130 * t197 * t203 * t205 * 2.0)
              + -(t189 * t194 * t203 * t205 * 2.0))
             + t194 * t197 * t204 * t206 * 2.0;
      t323 = ((((t129 * t191 * t202 * 2.0 + t319)
                + -(((t72 + t23 * t27 * 2.0) + -t73) * t203 * t206))
               + t129 * t196 * t203 * t205 * 2.0)
              + t191 * t199 * t203 * t205 * 2.0)
             + t196 * t199 * t204 * t206 * 2.0;
      t322 = ((((-(t125 * t190 * t202 * 2.0) + -t312)
                + ((t80 + t20 * t28 * 2.0) + -t82) * t203 * t206)
               + -(t125 * t200 * t203 * t205 * 2.0))
              + t190 * t193 * t203 * t205 * 2.0)
             + t193 * t200 * t204 * t206 * 2.0;
      t316 = ((((t130 * t190 * t202 * 2.0 + -t319)
                + -(((t73 + t24 * t26 * 2.0) + -t72) * t203 * t206))
               + t130 * t200 * t203 * t205 * 2.0)
              + t190 * t194 * t203 * t205 * 2.0)
             + t194 * t200 * t204 * t206 * 2.0;
      t65 = ((((-(t128 * t191 * t202 * 2.0) + -t317)
               + -(((t75 + t23 * t28 * 2.0) + -t78) * t203 * t206))
              + -(t128 * t196 * t203 * t205 * 2.0))
             + t191 * t195 * t203 * t205 * 2.0)
            + t195 * t196 * t204 * t206 * 2.0;
      t66 = ((((-(t127 * t190 * t202 * 2.0) + t314)
               + ((t73 + t20 * t26 * 2.0) + -t72) * t203 * t206)
              + -(t127 * t200 * t203 * t205 * 2.0))
             + -(t190 * t192 * t203 * t205 * 2.0))
            + -(t192 * t200 * t204 * t206 * 2.0);
      t13 = ((((t128 * t190 * t202 * 2.0 + t315)
               + -(((t80 + t24 * t28 * 2.0) + -t82) * t203 * t206))
              + t128 * t200 * t203 * t205 * 2.0)
             + -(t190 * t195 * t203 * t205 * 2.0))
            + -(t195 * t200 * t204 * t206 * 2.0);
      t12 = ((((-(t126 * t191 * t202 * 2.0) + -t314)
               + ((t72 + t18 * t27 * 2.0) + -t73) * t203 * t206)
              + -(t126 * t196 * t203 * t205 * 2.0))
             + -(t191 * t198 * t203 * t205 * 2.0))
            + -(t196 * t198 * t204 * t206 * 2.0);
      t11 = ((((t129 * t189 * t202 * 2.0 + -t315)
               + -(((t82 + t25 * t27 * 2.0) + -t80) * t203 * t206))
              + -(t129 * t197 * t203 * t205 * 2.0))
             + t189 * t199 * t203 * t205 * 2.0)
            + -(t197 * t199 * t204 * t206 * 2.0);
      H.val(0) = t151 * t202 * 2.0;
      H.val(1) = t262;
      H.val(2) = t241;
      H.val(3) = t606;
      H.val(4) = t622;
      H.val(5) = t625;
      H.val(6) = t599;
      H.val(7) = t619;
      H.val(8) = t612;
      H.val(9) = t603;
      H.val(10) = t610;
      H.val(11) = t615;
      H.val(12) = t262;
      H.val(13) = t150 * t202 * 2.0;
      H.val(14) = t261;
      H.val(15) = t621;
      H.val(16) = t607;
      H.val(17) = t620;
      H.val(18) = t617;
      H.val(19) = t602;
      H.val(20) = t616;
      H.val(21) = t609;
      H.val(22) = t604;
      H.val(23) = t608;
      H.val(24) = t241;
      H.val(25) = t261;
      H.val(26) = t149 * t202 * 2.0;
      H.val(27) = t624;
      H.val(28) = t623;
      H.val(29) = t605;
      H.val(30) = t611;
      H.val(31) = t618;
      H.val(32) = t601;
      H.val(33) = t614;
      H.val(34) = t613;
      H.val(35) = t600;
      H.val(36) = t606;
      H.val(37) = t621;
      H.val(38) = t624;
      H.val(39)
          = ((t191 * t191 * t202 * 2.0 + t196 * t196 * t204 * t206 * 2.0) - t646_tmp * (t45 + t46))
            + t191 * t196 * t203 * t205 * 4.0;
      H.val(40) = t99;
      H.val(41) = t85;
      H.val(42) = t638;
      H.val(43) = t323;
      H.val(44) = t65;
      H.val(45) = t635;
      H.val(46) = t12;
      H.val(47) = t135;
      H.val(48) = t622;
      H.val(49) = t607;
      H.val(50) = t623;
      H.val(51) = t99;
      H.val(52)
          = ((t190 * t190 * t202 * 2.0 + t200 * t200 * t204 * t206 * 2.0) - t646_tmp * (t44 + t46))
            + t190 * t200 * t203 * t205 * 4.0;
      H.val(53) = t90;
      H.val(54) = t316;
      H.val(55) = t71;
      H.val(56) = t13;
      H.val(57) = t66;
      H.val(58) = t86;
      H.val(59) = t322;
      H.val(60) = t625;
      H.val(61) = t620;
      H.val(62) = t605;
      H.val(63) = t85;
      H.val(64) = t90;
      H.val(65)
          = ((t189 * t189 * t202 * 2.0 + t197 * t197 * t204 * t206 * 2.0) - t646_tmp * (t44 + t45))
            - t189 * t197 * t203 * t205 * 4.0;
      H.val(66) = t321;
      H.val(67) = t11;
      H.val(68) = t636;
      H.val(69) = t324;
      H.val(70) = t318;
      H.val(71) = t637;
      H.val(72) = t599;
      H.val(73) = t617;
      H.val(74) = t611;
      H.val(75) = t638;
      H.val(76) = t316;
      H.val(77) = t321;
      H.val(78)
          = ((t130 * t130 * t202 * 2.0 + t194 * t194 * t204 * t206 * 2.0) - t646_tmp * (t42 + t43))
            + t130 * t194 * t203 * t205 * 4.0;
      H.val(79) = t631;
      H.val(80) = t627;
      H.val(81) = t633;
      H.val(82) = t646;
      H.val(83) = t133;
      H.val(84) = t619;
      H.val(85) = t602;
      H.val(86) = t618;
      H.val(87) = t323;
      H.val(88) = t71;
      H.val(89) = t11;
      H.val(90) = t631;
      H.val(91)
          = ((t129 * t129 * t202 * 2.0 + t199 * t199 * t204 * t206 * 2.0) - t646_tmp * (t41 + t43))
            + t129 * t199 * t203 * t205 * 4.0;
      H.val(92) = t629;
      H.val(93) = t645;
      H.val(94) = t634;
      H.val(95) = t325;
      H.val(96) = t612;
      H.val(97) = t616;
      H.val(98) = t601;
      H.val(99) = t65;
      H.val(100) = t13;
      H.val(101) = t636;
      H.val(102) = t627;
      H.val(103) = t629;
      H.val(104)
          = ((t128 * t128 * t202 * 2.0 + t195 * t195 * t204 * t206 * 2.0) - t646_tmp * (t41 + t42))
            - t128 * t195 * t203 * t205 * 4.0;
      H.val(105) = t77;
      H.val(106) = t131;
      H.val(107) = t632;
      H.val(108) = t603;
      H.val(109) = t609;
      H.val(110) = t614;
      H.val(111) = t635;
      H.val(112) = t66;
      H.val(113) = t324;
      H.val(114) = t633;
      H.val(115) = t645;
      H.val(116) = t77;
      H.val(117)
          = ((t127 * t127 * t202 * 2.0 + t192 * t192 * t204 * t206 * 2.0) - t646_tmp * (t39 + t40))
            + t127 * t192 * t203 * t205 * 4.0;
      H.val(118) = t630;
      H.val(119) = t626;
      H.val(120) = t610;
      H.val(121) = t604;
      H.val(122) = t613;
      H.val(123) = t12;
      H.val(124) = t86;
      H.val(125) = t318;
      H.val(126) = t646;
      H.val(127) = t634;
      H.val(128) = t131;
      H.val(129) = t630;
      H.val(130)
          = ((t126 * t126 * t202 * 2.0 + t198 * t198 * t204 * t206 * 2.0) - t646_tmp * (t38 + t40))
            + t126 * t198 * t203 * t205 * 4.0;
      H.val(131) = t628;
      H.val(132) = t615;
      H.val(133) = t608;
      H.val(134) = t600;
      H.val(135) = t135;
      H.val(136) = t322;
      H.val(137) = t637;
      H.val(138) = t133;
      H.val(139) = t325;
      H.val(140) = t632;
      H.val(141) = t626;
      H.val(142) = t628;
      H.val(143)
          = ((t125 * t125 * t202 * 2.0 + t193 * t193 * t204 * t206 * 2.0) - t646_tmp * (t38 + t39))
            - t125 * t193 * t203 * t205 * 4.0;
    }

  }  // namespace detail

#if 0
  template <typename VecTP, typename VecT>
  constexpr int pt_distance_type(const VecInterface<VecTP> &p, const VecInterface<VecT> &t0,
                                 const VecInterface<VecT> &t1, const VecInterface<VecT> &t2) {
    using T = math::op_result_t<typename VecTP::value_type, typename VecT::value_type>;
    constexpr int dim = VecTP::extent;
    using Ti = typename VecTP::index_type;

    typename VecTP::template variant_vec<T, integer_seq<Ti, 2, dim>> basis{};
    for (int d = 0; d != dim; ++d) {
      basis(0, d) = t1(d) - t0(d);
      basis(1, d) = t2(d) - t0(d);
    }

    const auto nVec = row(basis, 0).cross(row(basis, 1));

    typename VecTP::template variant_vec<T, integer_seq<Ti, 2, dim>> param{};

    {
      auto tmp = row(basis, 0).cross(nVec);
      for (int d = 0; d != dim; ++d) basis(1, d) = tmp(d);
    }
    {
      {
        // param.col(0) = (basis * basis.transpose()).ldlt().solve(basis * (p - t0));
        auto tmp = inverse(basis * basis.transpose()) * (basis * (p - t0));
        for (int d = 0; d != 2; ++d) param(d, 0) = tmp(d);
      }

      if (param(0, 0) > 0.0 && param(0, 0) < 1.0 && param(1, 0) >= 0.0) {
        return 3;  // PE t0t1
      } else {
        {
          // basis.row(0) = (t2 - t1).transpose();
          // basis.row(1) = basis.row(0).cross(nVec);
          auto tmp = t2 - t1;
          auto tmp1 = tmp.cross(nVec);
          for (int d = 0; d != dim; ++d) {
            basis(0, d) = tmp(d);
            basis(1, d) = tmp1(d);
          }
        }
        {
          // param.col(1) = (basis * basis.transpose()).ldlt().solve(basis * (p - t1));
          auto tmp = inverse(basis * basis.transpose()) * (basis * (p - t1));
          for (int d = 0; d != 2; ++d) param(d, 1) = tmp(d);
        }
        if (param(0, 1) > 0.0 && param(0, 1) < 1.0 && param(1, 1) >= 0.0) {
          return 4;  // PE t1t2
        } else {
          {
            // basis.row(0) = (t0 - t2).transpose();
            // basis.row(1) = basis.row(0).cross(nVec);
            auto tmp = t0 - t2;
            auto tmp1 = tmp.cross(nVec);
            for (int d = 0; d != dim; ++d) {
              basis(0, d) = tmp(d);
              basis(1, d) = tmp1(d);
            }
          }
          {
            // param.col(2) = (basis * basis.transpose()).ldlt().solve(basis * (p - t2));
            auto tmp = inverse(basis * basis.transpose()) * (basis * (p - t2));
            for (int d = 0; d != 2; ++d) param(d, 2) = tmp(d);
          }
          if (param(0, 2) > 0.0 && param(0, 2) < 1.0 && param(1, 2) >= 0.0)
            return 5;  // PE t2t0
          else {
            if (param(0, 0) <= 0.0 && param(0, 2) >= 1.0)
              return 0;  // PP t0
            else if (param(0, 1) <= 0.0 && param(0, 0) >= 1.0)
              return 1;  // PP t1
            else if (param(0, 2) <= 0.0 && param(0, 1) >= 1.0)
              return 2;  // PP t2
            else
              return 6;  // PT
          }
        }
      }
      return -1;
    }
  }
#else
  template <typename VecTP, typename VecT>
  constexpr int pt_distance_type(const VecInterface<VecTP> &p, const VecInterface<VecT> &t0,
                                 const VecInterface<VecT> &t1, const VecInterface<VecT> &t2) {
    using T = math::op_result_t<typename VecTP::value_type, typename VecT::value_type>;
    constexpr int dim = VecTP::extent;
    static_assert(dim == 3, "only implemented 3d version");
    using Ti = typename VecTP::index_type;
    using MatT = typename VecTP::template variant_vec<T, integer_seq<Ti, dim, dim>>;

    auto basis0 = t1 - t0;
    auto basis1 = t2 - t0;
    auto basis2 = p - t0;
    const auto nVec = cross(basis0, basis1);
    basis1 = basis0.cross(nVec);
    MatT D{}, D1{}, D2{};
    auto fillMats = [&]() {
      for (int d = 0; d != dim; ++d) {
        D(d, 0) = basis0[d];
        D(d, 1) = basis1[d];
        D(d, 2) = nVec[d];
        D1(d, 0) = basis2[d];
        D1(d, 1) = basis1[d];
        D1(d, 2) = nVec[d];
        D2(d, 0) = basis0[d];
        D2(d, 1) = basis2[d];
        D2(d, 2) = nVec[d];
      }
    };
    fillMats();
    T param[3][2] = {};
    {
      const auto detD = zs::determinant(D);
      param[0][0] = zs::determinant(D1) / detD;
      param[0][1] = zs::determinant(D2) / detD;
    }
    if (param[0][0] > 0 && param[0][0] < 1 && param[0][1] >= 0) return 3;  // PE t0t1

    basis0 = t2 - t1;
    basis1 = basis0.cross(nVec);
    basis2 = p - t1;
    fillMats();
    {
      const auto detD = zs::determinant(D);
      param[1][0] = zs::determinant(D1) / detD;
      param[1][1] = zs::determinant(D2) / detD;
    }
    if (param[1][0] > 0 && param[1][0] < 1 && param[1][1] >= 0) return 4;  // PE t1t2

    basis0 = t0 - t2;
    basis1 = basis0.cross(nVec);
    basis2 = p - t2;
    fillMats();
    {
      const auto detD = zs::determinant(D);
      param[2][0] = zs::determinant(D1) / detD;
      param[2][1] = zs::determinant(D2) / detD;
    }
    if (param[2][0] > 0 && param[2][0] < 1 && param[2][1] >= 0) return 5;  // PE t2t0

    if (param[0][0] <= 0 && param[2][0] >= 1) return 0;  // PP t0
    if (param[1][0] <= 0 && param[0][0] >= 1) return 1;  // PP t1
    if (param[2][0] <= 0 && param[1][0] >= 1) return 2;  // PP t2
    return 6;
  }
#endif

  template <
      typename VecTP, typename VecT,
      enable_if_all<VecTP::dim == 1, is_same_v<typename VecTP::dims, typename VecT::dims>> = 0>
  constexpr auto dist2_pt(const VecInterface<VecTP> &p, const VecInterface<VecT> &t0,
                          const VecInterface<VecT> &t1, const VecInterface<VecT> &t2) noexcept {
    using T = math::op_result_t<typename VecTP::value_type, typename VecT::value_type>;
    auto b = (t1 - t0).cross(t2 - t0);
    T aTb = (p - t0).dot(b);
    return aTb * aTb / b.l2NormSqr();
  }

  template <
      typename VecTP, typename VecT,
      enable_if_all<VecTP::dim == 1, is_same_v<typename VecTP::dims, typename VecT::dims>> = 0>
  constexpr auto dist2_pt_unclassified(const VecInterface<VecTP> &p, const VecInterface<VecT> &t0,
                                       const VecInterface<VecT> &t1,
                                       const VecInterface<VecT> &t2) noexcept {
    using T = math::op_result_t<typename VecTP::value_type, typename VecT::value_type>;
    T dist2{limits<T>::max()};
    switch (pt_distance_type(p, t0, t1, t2)) {
      case 0:
        dist2 = dist2_pp(p, t0);
        break;
      case 1:
        dist2 = dist2_pp(p, t1);
        break;
      case 2:
        dist2 = dist2_pp(p, t2);
        break;
      case 3:
        dist2 = dist2_pe(p, t0, t1);
        break;
      case 4:
        dist2 = dist2_pe(p, t1, t2);
        break;
      case 5:
        dist2 = dist2_pe(p, t2, t0);
        break;
      case 6:
        dist2 = dist2_pt(p, t0, t1, t2);
        break;
      default:
        break;
    }
    return dist2;
  }

  template <
      typename VecTP, typename VecT,
      enable_if_all<VecTP::dim == 1, is_same_v<typename VecTP::dims, typename VecT::dims>> = 0>
  constexpr auto dist_pt_unclassified(const VecInterface<VecTP> &p, const VecInterface<VecT> &t0,
                                      const VecInterface<VecT> &t1,
                                      const VecInterface<VecT> &t2) noexcept {
    return zs::sqrt(dist2_pt_unclassified(p, t0, t1, t2));
  }

  template <
      typename VecTP, typename VecT,
      enable_if_all<VecTP::dim == 1, is_same_v<typename VecTP::dims, typename VecT::dims>> = 0>
  constexpr auto dist_grad_pt(const VecInterface<VecTP> &p, const VecInterface<VecT> &t0,
                              const VecInterface<VecT> &t1, const VecInterface<VecT> &t2) noexcept {
    using T = math::op_result_t<typename VecTP::value_type, typename VecT::value_type>;
    using Ti = typename VecTP::index_type;
    constexpr int dim = VecTP::extent;
    static_assert(dim == 3, "currently only implement 3d version");
    using GradT = typename VecTP::template variant_vec<T, integer_seq<Ti, 4, dim>>;
    GradT grad{};
    detail::g_PT(p[0], p[1], p[2], t0[0], t0[1], t0[2], t1[0], t1[1], t1[2], t2[0], t2[1], t2[2],
                 grad);
    return grad;
  }

  template <
      typename VecTP, typename VecT,
      enable_if_all<VecTP::dim == 1, is_same_v<typename VecTP::dims, typename VecT::dims>> = 0>
  constexpr auto dist_hess_pt(const VecInterface<VecTP> &p, const VecInterface<VecT> &t0,
                              const VecInterface<VecT> &t1, const VecInterface<VecT> &t2) noexcept {
    using T = math::op_result_t<typename VecTP::value_type, typename VecT::value_type>;
    using Ti = typename VecTP::index_type;
    constexpr int dim = VecTP::extent;
    static_assert(dim == 3, "currently only implement 3d version");
    using HessT = typename VecTP::template variant_vec<T, integer_seq<Ti, dim * 4, dim * 4>>;
    HessT hess{};
    detail::H_PT(p[0], p[1], p[2], t0[0], t0[1], t0[2], t1[0], t1[1], t1[2], t2[0], t2[1], t2[2],
                 hess);
    return hess;
  }

  template <
      typename VecTE, typename VecT,
      enable_if_all<VecTE::dim == 1, is_same_v<typename VecTE::dims, typename VecT::dims>> = 0>
  constexpr bool et_intersected(const VecInterface<VecTE> &e0, const VecInterface<VecTE> &e1,
                                const VecInterface<VecT> &t0, const VecInterface<VecT> &t1,
                                const VecInterface<VecT> &t2) noexcept {
    using T = math::op_result_t<typename VecTE::value_type, typename VecT::value_type>;
    using Ti = typename VecTE::index_type;
    constexpr int dim = VecTE::extent;
    static_assert(dim == 3, "currently only implement 3d version");
    using MatT = typename VecTE::template variant_vec<T, integer_seq<Ti, dim, dim>>;
    auto col0 = t1 - t0;
    auto col1 = t2 - t0;
    auto col2 = e0 - e1;
    MatT mat{};
    auto setMatCols = [](auto &mat, const auto &col0, const auto &col1, const auto &col2) {
      for (int d = 0; d != dim; ++d) {
        mat(d, 0) = col0(d);
        mat(d, 1) = col1(d);
        mat(d, 2) = col2(d);
      }
    };
    setMatCols(mat, col0, col1, col2);
    auto n = col0.cross(col1);
    if (n.dot(e0 - t0) * n.dot(e1 - t0) > 0) return false;
    auto det = determinant(mat);
    if (det == 0) return false;

    MatT D1{}, D2{}, D3{};
    auto b = e0 - t0;
    setMatCols(D1, b, col1, col2);
    setMatCols(D2, col0, b, col2);
    setMatCols(D3, col0, col1, b);

    T uvt[3] = {determinant(D1) / det, determinant(D2) / det, determinant(D3) / det};

    if (uvt[0] >= 0 && uvt[1] >= 0 && uvt[0] + uvt[1] <= 1 && uvt[2] >= 0 && uvt[2] <= 1)
      return true;
    return false;
  }

}  // namespace zs